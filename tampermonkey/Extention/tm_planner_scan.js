// -------------------- MODULE SCROLL --------------------

(function() {
    'use strict';

    // Configuration
    const CONFIG = {
        scrollSpeed: 'instant', // Scroll instantan√© vers le bas
        buttonPosition: {
            top: '20px',
            right: '20px'
        },
        autoScrollClass: 'scrollable', // Classe principale √† cibler
        targetSelectors: [
            '.scrollable.scrollable-265',
            '.scrollable[data-can-drag-to-scroll="true"]',
            '.listWrapper',
            '.listBoxGroup',
            '.primarySection.taskBoardColumnGroup'
        ]
    };

    // Variables globales
    let scrollButton = null;
    let targetContainer = null;
    let debugMode = false;

    // Fonction de debug pour analyser le comportement du scroll
    function enableDebugMode() {
        debugMode = true;
        console.log('=== MODE DEBUG ACTIV√â ===');

        // Surveiller tous les √©v√©nements de scroll
        if (targetContainer) {
            targetContainer.addEventListener('scroll', function(e) {
                if (debugMode) {
                    console.log(`üìú SCROLL EVENT - Position: ${this.scrollTop}, Hauteur: ${this.scrollHeight}, Client: ${this.clientHeight}`);
                    console.log(`üìè Distance du bas: ${this.scrollHeight - this.scrollTop - this.clientHeight}px`);
                }
            });
        }

        // Surveiller les changements dans le DOM du conteneur
        if (targetContainer) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        console.log(`üîÑ DOM CHANGE - Ajout√©: ${mutation.addedNodes.length}, Supprim√©: ${mutation.removedNodes.length}`);
                        if (mutation.addedNodes.length > 0) {
                            console.log('üìã Nouveaux √©l√©ments:', mutation.addedNodes);
                        }
                    }
                });
            });

            observer.observe(targetContainer, {
                childList: true,
                subtree: true
            });
        }

        // Surveiller les requ√™tes r√©seau
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            console.log('üåê FETCH REQUEST:', args[0]);
            return originalFetch.apply(this, arguments).then(response => {
                console.log('‚úÖ FETCH RESPONSE:', response.status, args[0]);
                return response;
            });
        };

        // Surveiller XMLHttpRequest
        const originalXHR = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
            const xhr = new originalXHR();
            const originalOpen = xhr.open;
            const originalSend = xhr.send;

            xhr.open = function(method, url, ...args) {
                console.log(`üåê XHR ${method}:`, url);
                return originalOpen.apply(this, [method, url, ...args]);
            };

            xhr.addEventListener('load', function() {
                console.log('‚úÖ XHR RESPONSE:', this.status, this.responseURL);
            });

            return xhr;
        };
    }

    // Fonction pour cr√©er le bouton unifi√© (scroll + scan)
    function createUnifiedButton() {
        if (scrollButton) return; // √âviter les doublons

        // V√©rifier si on est sur Microsoft Planner
        if (!location.href.includes("planner.cloud.microsoft")) {
            console.log('[Bouton Unifi√©] Pas sur Microsoft Planner, bouton non cr√©√©');
            return; // Ne pas afficher le bouton si on n'est pas sur Microsoft Planner
        }

        console.log('[Bouton Unifi√©] Cr√©ation du bouton sur Microsoft Planner');
        scrollButton = document.createElement('button');
        scrollButton.id = 'unified-scan-scroll-button';
        scrollButton.textContent = 'SCAN';

        // Styles du bouton (style du bouton scan)
        Object.assign(scrollButton.style, {
            position: 'fixed',
            width: '65px',
            height: '65px',
            bottom: '20px',
            right: '20px',
            zIndex: '9999',
            padding: '10px 15px',
            background: 'rgba(0, 0, 0, 0.1)',
            color: '#fff',
            border: '2px solid rgb(255, 128, 0)',
            borderRadius: '50px',
            fontSize: '14px',
            cursor: 'pointer',
            boxShadow: '0 2px 8px rgba(255, 104, 0, 0.8)',
            backdropFilter: 'blur(5px)',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            transition: 'all 0.3s ease',
            userSelect: 'none'
        });

        // Ajouter l'animation CSS pour l'effet de clignotement
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% {
                    box-shadow: 0 2px 8px rgba(255, 104, 0, 0.8);
                    border-color: rgb(255, 128, 0);
                }
                50% {
                    box-shadow: 0 4px 20px rgba(255, 104, 0, 1);
                    border-color: rgb(255, 200, 0);
                }
                100% {
                    box-shadow: 0 2px 8px rgba(255, 104, 0, 0.8);
                    border-color: rgb(255, 128, 0);
                }
            }
        `;
        document.head.appendChild(style);

        // Effets hover
        scrollButton.addEventListener('mouseenter', () => {
            scrollButton.style.transform = 'scale(1.05)';
            scrollButton.style.boxShadow = '0 4px 12px rgba(255, 104, 0, 1)';
        });

        scrollButton.addEventListener('mouseleave', () => {
            scrollButton.style.transform = 'scale(1)';
            scrollButton.style.boxShadow = '0 2px 8px rgba(255, 104, 0, 0.8)';
        });

        // √âv√©nement click unifi√© (scroll d'abord, puis scan) - AVEC RELANCE POSSIBLE
        scrollButton.addEventListener('click', () => {
            if (scanInProgress) {
                console.log('[Bouton Unifi√©] üîÑ RELANCE: Arr√™t du scan en cours et red√©marrage complet...');
                scrollButton.textContent = 'RESTART';
                scrollButton.style.backgroundColor = 'rgba(255, 165, 0, 0.2)'; // Orange
                scrollButton.style.borderColor = 'rgb(255, 165, 0)';

                // Arr√™ter le scan en cours et r√©initialiser
                resetCompleteSystem();

                // Relancer apr√®s un d√©lai
                setTimeout(() => {
                    console.log('[Bouton Unifi√©] üöÄ RELANCE: D√©marrage du nouveau cycle complet...');
                    startCompleteScrollAndScanCycle();
                }, 1000);
            } else {
                console.log('[Bouton Unifi√©] üöÄ D√âMARRAGE: Lancement du cycle complet (Scroll ‚Üí Scan ‚Üí Actions)...');
                scrollButton.textContent = 'RUNNING';
                scrollButton.style.backgroundColor = 'rgba(0, 255, 0, 0.2)'; // Vert
                scrollButton.style.borderColor = 'rgb(0, 255, 0)';
                scrollButton.style.animation = ''; // Supprimer l'animation pulse

                startCompleteScrollAndScanCycle();
            }
        });

        // Ajouter le bouton au DOM
        document.body.appendChild(scrollButton);
    }

    // Fonction pour r√©initialiser compl√®tement le syst√®me
    function resetCompleteSystem() {
        console.log('[Syst√®me] üîÑ R√âINITIALISATION COMPL√àTE DU SYST√àME...');

        // Arr√™ter le scan en cours
        scanInProgress = false;

        // Arr√™ter la surveillance DOM
        if (domWatcher) {
            domWatcher.disconnect();
            domWatcher = null;
            console.log('[Syst√®me] üõë Surveillance DOM arr√™t√©e');
        }

        // Vider toutes les variables de scan
        tasksToScan = [];
        tasksResults.clear();
        pendingRequests = 0;
        processedTasks.clear();
        containersToProcess = [];

        console.log('[Syst√®me] üóëÔ∏è Toutes les variables de scan vid√©es');

        // Supprimer tous les overlays existants
        const existingOverlays = document.querySelectorAll('.autoelement');
        existingOverlays.forEach(overlay => overlay.remove());
        console.log(`[Syst√®me] üóëÔ∏è ${existingOverlays.length} overlays supprim√©s`);

        // Remettre le bouton √† l'√©tat initial
        if (scrollButton) {
            scrollButton.textContent = 'SCAN';
            scrollButton.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
            scrollButton.style.borderColor = 'rgb(255, 128, 0)';
        }

        console.log('[Syst√®me] ‚úÖ R√©initialisation compl√®te termin√©e');
    }

    // Fonction pour d√©marrer un cycle complet (scroll + scan)
    function startCompleteScrollAndScanCycle() {
        console.log('[Cycle Complet] üöÄ D√âMARRAGE DU CYCLE COMPLET: Scroll ‚Üí Scan ‚Üí Actions ‚Üí Scroll Final');

        // √âtape 1: Scroll initial
        console.log('[Cycle Complet] üìú √âTAPE 1/4: Scroll initial...');
        scrollToBottom();

        // √âtape 2: Premier scan apr√®s le scroll
        setTimeout(() => {
            console.log('[Cycle Complet] üîç √âTAPE 2/4: Premier scan apr√®s scroll...');
            if (window.scanContainers) {
                window.scanContainers();
            } else {
                console.log('[Cycle Complet] ‚ùå Fonction scanContainers non disponible');
                resetButtonToReady();
            }
        }, 3000); // 3 secondes pour laisser le scroll se terminer

        // Les √©tapes 3 et 4 (actions + scroll final) sont g√©r√©es automatiquement par le syst√®me existant
    }

    // Fonction pour remettre le bouton √† l'√©tat pr√™t
    function resetButtonToReady() {
        if (scrollButton) {
            // Remettre le style initial
            scrollButton.textContent = 'SCAN';
            scrollButton.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
            scrollButton.style.borderColor = 'rgb(255, 128, 0)';
            scrollButton.style.boxShadow = '0 2px 8px rgba(255, 104, 0, 0.8)';

            // Petit effet de clignotement pour indiquer que c'est pr√™t
            scrollButton.style.animation = 'pulse 2s ease-in-out 3';

            // Supprimer l'animation apr√®s
            setTimeout(() => {
                if (scrollButton) {
                    scrollButton.style.animation = '';
                }
            }, 6000);

            console.log('[Bouton] ‚úÖ Bouton SCAN pr√™t pour un nouveau lancement');
        }
        scanInProgress = false;
    }

    // Fonction pour analyser la structure DOM et les √©l√©ments
    function analyzeScrollStructure() {
        console.log('üîç === ANALYSE DE LA STRUCTURE DE SCROLL ===');

        const container = findScrollContainer();
        if (!container) {
            console.log('‚ùå Aucun conteneur trouv√©');
            return;
        }

        console.log('üì¶ Conteneur trouv√©:', container);
        console.log('üìê Dimensions:', {
            scrollHeight: container.scrollHeight,
            clientHeight: container.clientHeight,
            scrollTop: container.scrollTop
        });

        // Analyser les √©l√©ments enfants
        const children = container.children;
        console.log(`üë∂ Nombre d'enfants directs: ${children.length}`);

        // Trouver les √©l√©ments de t√¢ches
        const taskElements = container.querySelectorAll('[class*="taskCard"], [class*="taskBoardCard"], [class*="card"], [data-index]');
        console.log(`üìã √âl√©ments de t√¢ches trouv√©s: ${taskElements.length}`);

        // Analyser les attributs data
        const elementsWithDataIndex = container.querySelectorAll('[data-index]');
        if (elementsWithDataIndex.length > 0) {
            const indices = Array.from(elementsWithDataIndex).map(el => el.getAttribute('data-index'));
            console.log('üî¢ Indices des t√¢ches:', indices);
            console.log(`üìä Range des indices: ${Math.min(...indices)} √† ${Math.max(...indices)}`);
        }

        // Chercher des indicateurs de pagination/lazy loading
        const loadingElements = container.querySelectorAll('[class*="loading"], [class*="spinner"], [class*="loader"]');
        console.log(`‚è≥ √âl√©ments de chargement: ${loadingElements.length}`);

        // Chercher des zones de drop ou de contenu dynamique
        const dropZones = container.querySelectorAll('[data-dnd-role], [class*="dropZone"]');
        console.log(`üéØ Zones de drop: ${dropZones.length}`);

        // Analyser la position et l'√©tat du scroll
        const isAtBottom = container.scrollTop >= (container.scrollHeight - container.clientHeight - 10);
        console.log(`üìç Position: ${isAtBottom ? 'En bas' : 'Pas en bas'}`);

        // V√©rifier s'il y a des √©l√©ments invisibles en bas
        const containerRect = container.getBoundingClientRect();
        const elementsBelow = Array.from(taskElements).filter(el => {
            const rect = el.getBoundingClientRect();
            return rect.top > containerRect.bottom;
        });
        console.log(`üëª √âl√©ments invisibles en bas: ${elementsBelow.length}`);

        return container;
    }

    // Fonction pour attendre que le contenu se stabilise
    function waitForContentStabilization(container, callback, timeout = 1000) { // R√©duit de 2000ms √† 1000ms
        let lastHeight = container.scrollHeight;
        let stableCount = 0;
        const requiredStableChecks = 2; // R√©duit de 3 √† 2 v√©rifications
        const checkInterval = 100; // R√©duit de 200ms √† 100ms
        let totalWaited = 0;

        function checkStability() {
            const currentHeight = container.scrollHeight;

            if (currentHeight === lastHeight) {
                stableCount++;
                console.log(`üìè Hauteur stable (${stableCount}/${requiredStableChecks}): ${currentHeight}px`);

                if (stableCount >= requiredStableChecks) {
                    console.log('‚úÖ Contenu stabilis√©');
                    callback(true);
                    return;
                }
            } else {
                console.log(`üìà Hauteur chang√©e: ${lastHeight}px ‚Üí ${currentHeight}px`);
                lastHeight = currentHeight;
                stableCount = 0;
            }

            totalWaited += checkInterval;
            if (totalWaited >= timeout) {
                console.log('‚è∞ Timeout atteint pour la stabilisation');
                callback(false);
                return;
            }

            setTimeout(checkStability, checkInterval);
        }

        checkStability();
    }

    // Fonction pour trouver le conteneur de scroll
    function findScrollContainer() {
        // Essayer de trouver le conteneur par diff√©rents s√©lecteurs
        for (const selector of CONFIG.targetSelectors) {
            const container = document.querySelector(selector);
            if (container && container.scrollHeight > container.clientHeight) {
                console.log(`Conteneur trouv√© avec le s√©lecteur: ${selector}`);
                return container;
            }
        }

        // Fallback: chercher tout √©l√©ment avec la classe scrollable
        const scrollableElements = document.querySelectorAll('[class*="scrollable"]');
        for (const element of scrollableElements) {
            if (element.scrollHeight > element.clientHeight) {
                console.log('Conteneur trouv√© via fallback:', element.className);
                return element;
            }
        }

        console.warn('Aucun conteneur scrollable trouv√©');
        return null;
    }

    // Fonction de scroll progressif pour d√©clencher le lazy loading
    function scrollToBottom() {
        let attempts = 0;
        const maxAttempts = 50; // R√©duit car on a une meilleure logique maintenant
        const scrollStep = 5000; // Augment√© pour un scroll plus rapide

        function performProgressiveScroll() {
            // R√©cup√©rer une nouvelle r√©f√©rence du conteneur √† chaque tentative
            const container = findScrollContainer();
            if (!container) {
                console.error('‚ùå Conteneur perdu lors de la tentative', attempts + 1);
                return;
            }

            const currentScrollTop = container.scrollTop;
            const scrollHeight = container.scrollHeight;
            const clientHeight = container.clientHeight;
            const maxScrollTop = scrollHeight - clientHeight;

            console.log(`üîÑ Tentative ${attempts + 1}: Position ${currentScrollTop}/${maxScrollTop}, Hauteur totale: ${scrollHeight}`);

            // V√©rifier si on est d√©j√† au bas
            if (currentScrollTop >= maxScrollTop - 10) {
                console.log('üìç Atteint le bas, v√©rification de la stabilisation...');

                // Utiliser la nouvelle fonction de stabilisation
                waitForContentStabilization(container, (isStable) => {
                    if (!isStable && attempts < maxAttempts) {
                        console.log('üîÑ Contenu encore en chargement, tentative suivante...');
                        attempts++;
                        setTimeout(performProgressiveScroll, 50); // R√©duit √† 50ms pour quasi-instantan√©
                    } else {
                        const finalContainer = findScrollContainer();
                        if (finalContainer) {
                            console.log(`üéØ Scroll termin√© ! Tentatives: ${attempts + 1}`);
                            console.log(`üìä Hauteur finale: ${finalContainer.scrollHeight}px`);
                            console.log(`üìç Position finale: ${finalContainer.scrollTop}px`);

                            // Derni√®re analyse pour confirmer
                            const taskElements = finalContainer.querySelectorAll('[data-index]');
                            if (taskElements.length > 0) {
                                const indices = Array.from(taskElements).map(el => parseInt(el.getAttribute('data-index')));
                                console.log(`üìã Total des t√¢ches charg√©es: ${taskElements.length}`);
                                console.log(`üìä Range final: ${Math.min(...indices)} √† ${Math.max(...indices)}`);
                            }
                        }
                    }
                }, 800); // R√©duit de 1500ms √† 800ms pour plus de rapidit√©
            } else {
                // Pas encore au bas, scroller par √©tapes
                const targetScroll = Math.min(currentScrollTop + scrollStep, maxScrollTop);
                container.scrollTop = targetScroll;

                // D√©clencher des √©v√©nements pour s'assurer que les listeners se d√©clenchent
                container.dispatchEvent(new Event('scroll', { bubbles: true }));

                // Simuler aussi un √©v√©nement wheel pour certains lazy loaders
                container.dispatchEvent(new WheelEvent('wheel', {
                    deltaY: scrollStep,
                    bubbles: true
                }));

                attempts++;
                if (attempts < maxAttempts) {
                    setTimeout(performProgressiveScroll, 50); // R√©duit √† 50ms pour quasi-instantan√©
                } else {
                    console.log('‚ö†Ô∏è Limite de tentatives atteinte sans atteindre le bas.');
                }
            }
        }

        // V√©rification initiale
        const initialContainer = findScrollContainer();
        if (!initialContainer) {
            alert('‚ùå Aucun conteneur scrollable trouv√© sur cette page.');
            return;
        }

        console.log('üöÄ === D√âMARRAGE DU SCROLL AM√âLIOR√â ===');
        console.log(`üìê Dimensions initiales: ${initialContainer.scrollHeight}px (visible: ${initialContainer.clientHeight}px)`);

        // Compter les t√¢ches initiales
        const initialTasks = initialContainer.querySelectorAll('[data-index]');
        console.log(`üìã T√¢ches initialement visibles: ${initialTasks.length}`);

        performProgressiveScroll();
    }

    // Fonction pour surveiller les changements dans le DOM
    function observeDOMChanges() {
        const observer = new MutationObserver((mutations) => {
            // Observer les changements pour maintenir la r√©f√©rence au conteneur √† jour
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    // R√©initialiser la r√©f√©rence du conteneur si n√©cessaire
                    setTimeout(() => {
                        targetContainer = null;
                    }, 100);
                }
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    // Fonction d'initialisation du module scroll
    function initScrollModule() {
        // Attendre que le DOM soit compl√®tement charg√©
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initScrollModule);
            return;
        }

        // D√©lai pour s'assurer que l'interface est compl√®tement rendue
        setTimeout(() => {
            createUnifiedButton();
            observeDOMChanges();
            console.log('Bouton unifi√© (Scroll + Scan) initialis√©');
        }, 1000);
    }

    // Raccourci clavier pour scroll instantan√© (Ctrl + Shift + S)
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'S') {
            e.preventDefault();
            scrollToBottom();
        }
    });

    // Initialiser le module scroll
    initScrollModule();

    // Exposer les fonctions globalement pour les rendre accessibles depuis l'ext√©rieur du module
    window.resetCompleteSystem = resetCompleteSystem;
    window.startCompleteScrollAndScanCycle = startCompleteScrollAndScanCycle;
    window.resetButtonToReady = resetButtonToReady;

})();

// -------------------- MODULE LISTE --------------------

// Liste configurable par l'utilisateur
const DEFAULT_LIST = "non trouv√©, ATTENTE RT, ATTENTE REBUT, ATTENTE COMPOSANT, SOUS TRAITANCE, SOUS-TRAITANCE, CONTROLE QUALITE, ATTENTE SUPPORT";

function getList() {
    return GM_getValue("autoListFinish", DEFAULT_LIST).split(",").map(s => s.trim());
}

function editList() {
    const current = GM_getValue("autoListFinish", DEFAULT_LIST);
    const next = prompt("Entre ta liste d'√©l√©ments s√©par√©s par des virgules:", current);
    if (next !== null) GM_setValue("autoListFinish", next);
}

function showList() {
    alert("Liste actuelle:\n" + getList().join("\n"));
}

// Menus Tampermonkey pour la liste
GM_registerMenuCommand("‚úèÔ∏è Modifier la liste", editList);
GM_registerMenuCommand("üìã Afficher la liste", showList);

// -------------------- SCRIPT PRINCIPAL --------------------

// Variables globales pour le scan
const processedSections = new WeakMap();
const donneesTaches = []; // tableau global pour stocker les infos extraites
let liensEnCours = 0;
let postEnCours = 0;

// Variables pour la surveillance DOM et le scan
let scanInProgress = false;
let domWatcher = null;
let processedTasks = new Set(); // Pour √©viter les doublons
let containersToProcess = []; // Liste temporaire pour compatibility

// Variables pour la s√©paration scan/d√©placement
let tasksToScan = [];
let tasksResults = new Map(); // stocke les r√©sultats des scans
let pendingRequests = 0;
let maxConcurrentRequests = 5;

function scanContainers() {
    console.log('[Planner Script] üöÄ SYST√àME SIMPLIFI√â: Scan unique puis d√©placements...');

    // Si un scan est d√©j√† en cours, l'arr√™ter proprement
    if (scanInProgress) {
        console.log('[Planner Script] ‚ö†Ô∏è Scan d√©j√† en cours, arr√™t du pr√©c√©dent scan');
        stopDOMWatcher();
    }

    // Marquer le scan comme en cours
    scanInProgress = true;

    // Lancer directement le syst√®me simplifi√©
    console.log('[Planner Script] üöÄ Lancement du syst√®me simplifi√©...');
    startSimplifiedScanAndMove();
}

// SYST√àME SIMPLIFI√â: Scan unique puis d√©placements
function startSimplifiedScanAndMove() {
    console.log('[Planner Script] üéØ D√âBUT DU SYST√àME SIMPLIFI√â');

    // Chercher les conteneurs avec priorit√© : listBoxGroup d'abord, puis taskBoardCard
    let containers = document.querySelectorAll('.listBoxGroup .taskBoardCard');

    if (containers.length === 0) {
        containers = document.querySelectorAll('.taskBoardCard');
    }

    if (containers.length === 0) {
        console.log('[Planner Script] ‚ùå Aucun conteneur trouv√©');
        return;
    }

    console.log(`[Planner Script] üîç √âTAPE 1: Scan de ${containers.length} t√¢ches...`);
    console.log(`[Planner Script] ÔøΩ `);
}

// SYST√àME SIMPLIFI√â: Scan unique puis d√©placements
function startSimplifiedScanAndMove() {
    console.log('[Planner Script] üéØ D√âBUT DU SYST√àME SIMPLIFI√â');

    // Chercher les conteneurs avec priorit√© : listBoxGroup d'abord, puis taskBoardCard
    let containers = document.querySelectorAll('.listBoxGroup .taskBoardCard');

    if (containers.length === 0) {
        containers = document.querySelectorAll('.taskBoardCard');
    }

    if (containers.length === 0) {
        console.log('[Planner Script] ‚ùå Aucun conteneur trouv√©');
        return;
    }

    console.log(`[Planner Script] üîç √âTAPE 1: Scan de ${containers.length} t√¢ches...`);

    // R√©initialiser les variables
    tasksToScan = [];
    tasksResults.clear();
    pendingRequests = 0;

    // Pr√©parer toutes les t√¢ches √† scanner
    containers.forEach((container, index) => {
        const taskCard = container.querySelector('div.taskCard');
        if (!taskCard) return;

        const lienElement = container.querySelector('a.referencePreviewDescription');
        let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');
        if (lien && !lien.endsWith('.html')) lien += '.html';
        if (!lien || !lien.includes('.html')) return;

        const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];
        if (!numeroReparation || processedTasks.has(numeroReparation)) return;

        processedTasks.add(numeroReparation);
        ajouterOverlayTaskCard(taskCard, numeroReparation, 'Scan...');

        tasksToScan.push({
            container,
            taskCard,
            lien,
            numeroReparation,
            index: index + 1
        });
    });

    console.log(`[Planner Script] üìã ${tasksToScan.length} t√¢ches pr√©par√©es pour le scan`);

    if (tasksToScan.length > 0) {
        // Lancer tous les scans en parall√®le (rapide)
        startSimplifiedScanning();
    }
}

// Scan simplifi√© en parall√®le
function startSimplifiedScanning() {
    console.log(`[Planner Script] üöÄ Lancement du scan de ${tasksToScan.length} t√¢ches en parall√®le...`);

    tasksToScan.forEach((task, index) => {
        // Petit d√©lai √©chelonn√© pour √©viter la surcharge
        setTimeout(() => {
            scanTaskSimplified(task);
        }, index * 100); // 100ms entre chaque requ√™te
    });
}

// Scan d'une t√¢che (version simplifi√©e)
function scanTaskSimplified(task) {
    const { lien, numeroReparation, taskCard } = task;
    pendingRequests++;

    GM_xmlhttpRequest({
        method: 'GET',
        url: lien,
        onload: function (response) {
            handleSimplifiedScanResult(response, task);
        },
        onerror: function () {
            console.log(`[Planner Script] ‚ùå Erreur scan ${numeroReparation}`);
            pendingRequests--;
            checkSimplifiedScanCompletion();
        }
    });
}

// Traitement du r√©sultat de scan (simplifi√©)
function handleSimplifiedScanResult(response, task) {
    const { numeroReparation, taskCard } = task;
    pendingRequests--;

    let texteLabel = 'Erreur';
    let canMove = false;
    let canComplete = false;

    if (response.status === 200) {
        const html = response.responseText;
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        const label = doc.querySelector('span.label-success');
        texteLabel = label?.textContent?.trim() || 'non trouv√©';

        // Cas PV
        if (texteLabel === 'non trouv√©' && response.finalUrl?.includes('/Prm/AfficherPv/')) {
            texteLabel = 'Termin√© / PV';
        }

        // D√©terminer si on doit cocher (completion) et/ou d√©placer
        const autoListFinish = getList();
        const matchInList = autoListFinish.some(item => texteLabel.includes(item));
        const containsPieceEnProd = texteLabel.includes('PIECE EN PROD');
        canMove = !containsPieceEnProd && !matchInList;

        // D√©terminer si on doit cocher (t√¢ches dans la liste configurable)
        canComplete = matchInList && !containsPieceEnProd;
    }

    // Stocker le r√©sultat
    tasksResults.set(numeroReparation, {
        texteLabel,
        canMove,
        canComplete,
        taskCard,
        originalContainer: task.container
    });

    // Mettre √† jour l'overlay
    const overlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
    if (overlay) {
        const textElement = overlay.querySelector('.text-collector');
        if (textElement) {
            if (canComplete) {
                textElement.textContent = '‚úÖ ' + texteLabel;
                overlay.style.backgroundColor = 'rgba(0, 0, 255, 0.8)'; // Bleu pour cochage
            } else if (canMove) {
                textElement.textContent = 'üöÄ ' + texteLabel;
                overlay.style.backgroundColor = 'rgba(0, 255, 0, 0.8)'; // Vert pour d√©placement
            } else {
                textElement.textContent = '‚è∏Ô∏è ' + texteLabel;
                overlay.style.backgroundColor = 'rgba(128, 128, 128, 0.8)'; // Gris pour aucune action
            }
        }
    }

    let actionText = '';
    if (canComplete) actionText = '(√† cocher)';
    else if (canMove) actionText = '(√† d√©placer)';
    else actionText = '(aucune action)';

    console.log(`[Planner Script] ‚úÖ ${numeroReparation}: ${texteLabel} ${actionText}`);
    console.log(`[Planner Script] üìä Requ√™tes restantes: ${pendingRequests}`);
    checkSimplifiedScanCompletion();
}

// V√©rifier si le scan est termin√©
function checkSimplifiedScanCompletion() {
    console.log(`[Planner Script] üîç V√©rification completion: ${pendingRequests} requ√™tes restantes`);
    if (pendingRequests === 0) {
        const movableTasks = Array.from(tasksResults.entries()).filter(([_, result]) => result.canMove);
        const completableTasks = Array.from(tasksResults.entries()).filter(([_, result]) => result.canComplete);

        console.log(`[Planner Script] üéâ √âTAPE 1 TERMIN√âE: ${tasksResults.size} t√¢ches scann√©es`);
        console.log(`[Planner Script] üìä ${completableTasks.length} t√¢ches √† cocher, ${movableTasks.length} t√¢ches √† d√©placer`);

        if (completableTasks.length > 0) {
            // √âTAPE 2A: D'abord cocher les t√¢ches termin√©es (PRIORIT√â)
            console.log('[Planner Script] üéØ ORDRE D\'EX√âCUTION: 1) Cochage des t√¢ches termin√©es, puis 2) D√©placements');
            setTimeout(() => {
                startSimplifiedCompletions(completableTasks, movableTasks);
            }, 2000);
        } else if (movableTasks.length > 0) {
            // √âTAPE 2B: Directement aux d√©placements si pas de cochage
            setTimeout(() => {
                startSimplifiedMovements(movableTasks);
            }, 2000);
        } else {
            console.log('[Planner Script] ‚úÖ Aucune action n√©cessaire, scan termin√©');
            // Faire quand m√™me la restauration finale pour afficher les statuts
            setTimeout(() => {
                performFinalOverlayRestoration();
            }, 1000);
            scanInProgress = false;
        }
    }
}

// √âTAPE 2A: Completions (cochages) s√©quentiels
function startSimplifiedCompletions(completableTasks, movableTasks) {
    console.log(`[Planner Script] ‚úÖ √âTAPE 2A: Cochage de ${completableTasks.length} t√¢ches termin√©es...`);

    completableTasks.forEach(([numeroReparation, result], index) => {
        setTimeout(async () => {
            console.log(`[Planner Script] ‚úÖ Cochage ${index + 1}/${completableTasks.length}: ${numeroReparation}`);

            // Rechercher la t√¢che dans le DOM actuel
            const currentTaskCard = await findCurrentTaskCard(numeroReparation);
            if (currentTaskCard) {
                // Effectuer le cochage
                tryClickComplete(currentTaskCard, numeroReparation, result.texteLabel);

                // Mettre √† jour l'overlay pour indiquer le cochage effectu√©
                setTimeout(() => {
                    const overlay = currentTaskCard.querySelector(`#idreparation-status-${numeroReparation}`);
                    if (overlay) {
                        const textElement = overlay.querySelector('.text-collector');
                        if (textElement) {
                            textElement.textContent = '‚úÖ Coch√©e: ' + result.texteLabel;
                            overlay.style.backgroundColor = 'rgba(0, 150, 255, 0.9)'; // Bleu plus fonc√©
                        }
                    }
                }, 1000);
            } else {
                console.log(`[Planner Script] ‚ùå T√¢che ${numeroReparation} non trouv√©e pour cochage`);
            }

            // Si c'est la derni√®re completion
            if (index === completableTasks.length - 1) {
                setTimeout(() => {
                    console.log('[Planner Script] ‚úÖ √âTAPE 2A TERMIN√âE: Tous les cochages effectu√©s!');

                    // Passer aux d√©placements si n√©cessaire
                    if (movableTasks.length > 0) {
                        console.log(`[Planner Script] üîÑ √âTAPE 2A TERMIN√âE ‚Üí Passage √† l'√©tape 2B: D√©placements...`);
                        console.log(`[Planner Script] ‚è±Ô∏è Attente de 2 secondes avant de commencer les d√©placements...`);
                        setTimeout(() => {
                            startSimplifiedMovements(movableTasks);
                        }, 2000);
                    } else {
                        console.log('[Planner Script] ‚úÖ TOUTES LES ACTIONS TERMIN√âES!');
                        setTimeout(() => {
                            performFinalOverlayRestoration();
                        }, 2000);
                        scanInProgress = false;
                    }
                }, 2000);
            }
        }, index * 3000); // 3 secondes entre chaque cochage
    });
}

// √âTAPE 2B: D√©placements s√©quentiels
function startSimplifiedMovements(movableTasks) {
    console.log(`[Planner Script] üöÄ √âTAPE 2: D√©placement de ${movableTasks.length} t√¢ches...`);

    // D√©marrer la maintenance p√©riodique des overlays
    const overlayMaintenance = setInterval(() => {
        restoreAllOverlays();
    }, 3000); // Restaurer les overlays toutes les 3 secondes

    movableTasks.forEach(([numeroReparation, result], index) => {
        setTimeout(async () => {
            console.log(`[Planner Script] üöÄ D√©placement ${index + 1}/${movableTasks.length}: ${numeroReparation}`);

            // Rechercher la t√¢che dans le DOM actuel
            const currentTaskCard = await findCurrentTaskCard(numeroReparation);
            if (currentTaskCard) {
                // Effectuer le d√©placement
                tryMoveTaskToDropZone(currentTaskCard, numeroReparation, result.texteLabel);

                // Attendre un peu puis restaurer TOUS les overlays
                setTimeout(() => {
                    restoreAllOverlays();
                }, 2000);
            } else {
                console.log(`[Planner Script] ‚ùå T√¢che ${numeroReparation} non trouv√©e pour d√©placement`);
            }

            // Si c'est le dernier d√©placement
            if (index === movableTasks.length - 1) {
                setTimeout(() => {
                    console.log('[Planner Script] ‚úÖ TOUS LES D√âPLACEMENTS TERMIN√âS!');
                    // Arr√™ter la maintenance p√©riodique
                    clearInterval(overlayMaintenance);
                    // Restauration finale compl√®te
                    performFinalOverlayRestoration();
                    scanInProgress = false;
                }, 4000);
            }
        }, index * 6000); // 6 secondes entre chaque d√©placement (plus de temps)
    });
}

// Fonction pour restaurer tous les overlays apr√®s les d√©placements
function restoreAllOverlays() {
    if (tasksResults.size === 0) return;

    let overlaysChecked = 0;
    let overlaysRestored = 0;

    // Rechercher tous les conteneurs actuels
    const allContainers = document.querySelectorAll('.taskBoardCard');

    allContainers.forEach(container => {
        const lienElement = container.querySelector('a.referencePreviewDescription');
        let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

        if (lien) {
            if (!lien.endsWith('.html')) lien += '.html';
            const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];

            // V√©rifier si on a des r√©sultats pour cette t√¢che
            if (numeroReparation && tasksResults.has(numeroReparation)) {
                overlaysChecked++;
                const result = tasksResults.get(numeroReparation);
                const taskCard = container.querySelector('div.taskCard');

                if (taskCard) {
                    // V√©rifier si l'overlay existe d√©j√† et est visible
                    const existingOverlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);

                    if (!existingOverlay || existingOverlay.style.display === 'none') {
                        // Recr√©er l'overlay
                        const displayText = result.canMove ? 'üöÄ ' + result.texteLabel : '‚è∏Ô∏è ' + result.texteLabel;
                        ajouterOverlayTaskCard(taskCard, numeroReparation, displayText);

                        // Appliquer le style apr√®s cr√©ation
                        setTimeout(() => {
                            const newOverlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
                            if (newOverlay) {
                                const backgroundColor = result.canMove ? 'rgba(0, 255, 0, 0.8)' : 'rgba(128, 128, 128, 0.8)';
                                newOverlay.style.backgroundColor = backgroundColor;
                                newOverlay.style.display = 'block';
                                newOverlay.style.visibility = 'visible';
                            }
                        }, 50);

                        overlaysRestored++;
                    } else {
                        // S'assurer que l'overlay existant est visible et √† jour
                        const textElement = existingOverlay.querySelector('.text-collector');
                        if (textElement) {
                            const displayText = result.canMove ? 'üöÄ ' + result.texteLabel : '‚è∏Ô∏è ' + result.texteLabel;
                            textElement.textContent = displayText;
                        }

                        const backgroundColor = result.canMove ? 'rgba(0, 255, 0, 0.8)' : 'rgba(128, 128, 128, 0.8)';
                        existingOverlay.style.backgroundColor = backgroundColor;
                        existingOverlay.style.display = 'block';
                        existingOverlay.style.visibility = 'visible';
                    }
                }
            }
        }
    });

    if (overlaysRestored > 0) {
        console.log(`[Planner Script] üîÑ ${overlaysRestored}/${overlaysChecked} overlays restaur√©s`);
    }
}

// Fonction pour la restauration finale compl√®te de tous les overlays
function performFinalOverlayRestoration() {
    console.log('[Planner Script] üé® RESTAURATION FINALE: Affichage de tous les overlays...');

    // Attendre un peu pour que l'interface se stabilise compl√®tement
    setTimeout(() => {
        let totalRestored = 0;
        let totalTasks = tasksResults.size;

        // Rechercher tous les conteneurs dans toutes les colonnes
        const allContainers = document.querySelectorAll('.taskBoardCard');
        console.log(`[Planner Script] üîç Recherche dans ${allContainers.length} conteneurs...`);

        allContainers.forEach(container => {
            const lienElement = container.querySelector('a.referencePreviewDescription');
            let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

            if (lien) {
                if (!lien.endsWith('.html')) lien += '.html';
                const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];

                if (numeroReparation && tasksResults.has(numeroReparation)) {
                    const result = tasksResults.get(numeroReparation);
                    const taskCard = container.querySelector('div.taskCard');

                    if (taskCard) {
                        // Supprimer l'ancien overlay s'il existe
                        const oldOverlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
                        if (oldOverlay) {
                            oldOverlay.remove();
                        }

                        // D√©terminer le texte et la couleur selon l'√©tat final
                        let displayText, backgroundColor;

                        // V√©rifier dans quelle colonne se trouve maintenant la t√¢che
                        const parentColumn = container.closest('.listBoxGroup');
                        let columnName = 'Inconnue';
                        if (parentColumn) {
                            const columnHeader = parentColumn.querySelector('[data-automation-id="task-bucket-header"]');
                            columnName = columnHeader?.textContent?.trim() || 'Inconnue';
                        }

                        // V√©rifier si la t√¢che a √©t√© coch√©e (peut √™tre dans la colonne "Termin√©")
                        const isInCompletedColumn = columnName.includes('Termin√©') || columnName.includes('Completed') || columnName.includes('Done');

                        if (result.canComplete && isInCompletedColumn) {
                            // T√¢che coch√©e avec succ√®s
                            displayText = '‚úÖ Coch√©e et termin√©e: ' + result.texteLabel;
                            backgroundColor = 'rgba(0, 100, 255, 0.9)'; // Bleu fonc√©
                        } else if (result.canComplete) {
                            // T√¢che qui devait √™tre coch√©e
                            displayText = '‚úÖ Coch√©e: ' + result.texteLabel;
                            backgroundColor = 'rgba(0, 150, 255, 0.9)'; // Bleu
                        } else if (columnName.includes('En cours') || columnName.includes('In Progress')) {
                            // T√¢che d√©plac√©e avec succ√®s
                            displayText = 'üöÄ D√©plac√©e: ' + result.texteLabel;
                            backgroundColor = 'rgba(0, 200, 0, 0.9)'; // Vert
                        } else if (result.canMove) {
                            // T√¢che qui devait √™tre d√©plac√©e mais qui n'a pas boug√©
                            displayText = 'üîÑ √Ä d√©placer: ' + result.texteLabel;
                            backgroundColor = 'rgba(255, 165, 0, 0.9)'; // Orange
                        } else {
                            // T√¢che qui ne devait pas √™tre d√©plac√©e
                            displayText = '‚è∏Ô∏è Aucune action: ' + result.texteLabel;
                            backgroundColor = 'rgba(128, 128, 128, 0.8)'; // Gris
                        }

                        // Cr√©er le nouvel overlay avec le statut final
                        ajouterOverlayTaskCard(taskCard, numeroReparation, displayText);

                        // Appliquer le style final
                        setTimeout(() => {
                            const finalOverlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
                            if (finalOverlay) {
                                finalOverlay.style.backgroundColor = backgroundColor;
                                finalOverlay.style.display = 'block';
                                finalOverlay.style.visibility = 'visible';
                                finalOverlay.style.opacity = '1';
                                finalOverlay.style.zIndex = '9999';

                                // Ajout d'un petit effet de mise en surbrillance
                                finalOverlay.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                                finalOverlay.style.borderRadius = '4px';
                            }
                        }, 100);

                        totalRestored++;
                        console.log(`[Planner Script] üé® ${numeroReparation} dans "${columnName}": ${displayText}`);
                    }
                }
            }
        });

        // Rapport final
        setTimeout(() => {
            console.log(`[Planner Script] üéâ RESTAURATION FINALE TERMIN√âE!`);
            console.log(`[Planner Script] üìä ${totalRestored}/${totalTasks} overlays affich√©s`);
            console.log(`[Planner Script] ‚úÖ Tous les statuts sont maintenant visibles`);

            // Afficher un r√©sum√© des r√©sultats
            displayFinalSummary();
        }, 1000);

    }, 2000); // D√©lai initial pour stabiliser l'interface
}

// Fonction pour afficher un r√©sum√© final
function displayFinalSummary() {
    let moved = 0;
    let completed = 0;
    let shouldHaveMoved = 0;
    let shouldHaveCompleted = 0;
    let noAction = 0;

    // Compter les r√©sultats finaux
    document.querySelectorAll('.taskBoardCard').forEach(container => {
        const lienElement = container.querySelector('a.referencePreviewDescription');
        let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

        if (lien) {
            if (!lien.endsWith('.html')) lien += '.html';
            const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];

            if (numeroReparation && tasksResults.has(numeroReparation)) {
                const result = tasksResults.get(numeroReparation);
                const parentColumn = container.closest('.listBoxGroup');

                if (parentColumn) {
                    const columnHeader = parentColumn.querySelector('[data-automation-id="task-bucket-header"]');
                    const columnName = columnHeader?.textContent?.trim() || '';

                    const isInCompletedColumn = columnName.includes('Termin√©') || columnName.includes('Completed') || columnName.includes('Done');
                    const isInProgressColumn = columnName.includes('En cours') || columnName.includes('In Progress');

                    if (result.canComplete && isInCompletedColumn) {
                        completed++;
                    } else if (result.canComplete) {
                        shouldHaveCompleted++;
                    } else if (isInProgressColumn) {
                        moved++;
                    } else if (result.canMove) {
                        shouldHaveMoved++;
                    } else {
                        noAction++;
                    }
                }
            }
        }
    });

    console.log(`[Planner Script] üìà R√âSUM√â FINAL:`);
    console.log(`[Planner Script] ‚úÖ T√¢ches coch√©es et termin√©es: ${completed}`);
    console.log(`[Planner Script] üîÑ T√¢ches qui auraient d√ª √™tre coch√©es: ${shouldHaveCompleted}`);
    console.log(`[Planner Script] üöÄ T√¢ches d√©plac√©es avec succ√®s: ${moved}`);
    console.log(`[Planner Script] üîÑ T√¢ches qui auraient d√ª √™tre d√©plac√©es: ${shouldHaveMoved}`);
    console.log(`[Planner Script] ‚è∏Ô∏è T√¢ches sans action (normal): ${noAction}`);

    // √âTAPE FINALE: Dernier scroll + scan complet pour nouvelles t√¢ches
    setTimeout(() => {
        startFinalScrollAndScan();
    }, 3000);
}

// √âTAPE FINALE: Dernier scroll puis scan complet des nouvelles t√¢ches
function startFinalScrollAndScan() {
    console.log(`[Planner Script] üèÅ √âTAPE FINALE: Dernier scroll + scan des nouvelles t√¢ches...`);

    // D'abord effectuer un scroll final pour r√©v√©ler toutes les t√¢ches
    performFinalScroll().then(() => {
        // Attendre que le contenu se stabilise apr√®s le scroll
        setTimeout(() => {
            performFinalCompleteScan();
        }, 2000);
    });
}

// Fonction pour effectuer le scroll final
function performFinalScroll() {
    return new Promise((resolve) => {
        console.log(`[Planner Script] üìú Scroll final pour r√©v√©ler toutes les t√¢ches...`);

        // Utiliser la fonction de scroll existante du module scroll
        const container = findScrollContainer();
        if (!container) {
            console.log(`[Planner Script] ‚ùå Aucun conteneur scrollable trouv√© pour le scroll final`);
            resolve();
            return;
        }

        // Scroll progressif vers le bas
        let currentScrollTop = container.scrollTop;
        const maxScrollTop = container.scrollHeight - container.clientHeight;
        const scrollStep = 3000; // 3000px √† la fois

        console.log(`[Planner Script] üìê Scroll de ${currentScrollTop} vers ${maxScrollTop} (total: ${container.scrollHeight}px)`);

        function scrollStepByStep() {
            if (currentScrollTop >= maxScrollTop - 10) {
                console.log(`[Planner Script] ‚úÖ Scroll final termin√©!`);
                resolve();
                return;
            }

            currentScrollTop = Math.min(currentScrollTop + scrollStep, maxScrollTop);
            container.scrollTop = currentScrollTop;

            console.log(`[Planner Script] üìú Scroll √† ${currentScrollTop}px...`);

            // Attendre un peu pour que le contenu se charge
            setTimeout(scrollStepByStep, 800);
        }

        scrollStepByStep();
    });
}

// Fonction pour scanner toutes les t√¢ches apr√®s le scroll final
function performFinalCompleteScan() {
    console.log(`[Planner Script] üîç SCAN FINAL COMPLET: Recherche de nouvelles t√¢ches...`);

    // Chercher tous les conteneurs apr√®s le scroll
    let allContainers = document.querySelectorAll('.listBoxGroup .taskBoardCard');
    if (allContainers.length === 0) {
        allContainers = document.querySelectorAll('.taskBoardCard');
    }

    console.log(`[Planner Script] üìä ${allContainers.length} conteneurs trouv√©s apr√®s scroll final`);

    // Identifier les nouvelles t√¢ches
    const newTasks = [];
    let totalTasks = 0;
    let alreadyProcessed = 0;

    allContainers.forEach((container, index) => {
        const lienElement = container.querySelector('a.referencePreviewDescription');
        let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

        if (lien) {
            if (!lien.endsWith('.html')) lien += '.html';
            const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];

            if (numeroReparation) {
                totalTasks++;

                // V√©rifier si cette t√¢che a d√©j√† √©t√© trait√©e
                if (tasksResults.has(numeroReparation)) {
                    alreadyProcessed++;
                } else {
                    // Nouvelle t√¢che trouv√©e !
                    const taskCard = container.querySelector('div.taskCard');
                    if (taskCard) {
                        newTasks.push({
                            container,
                            taskCard,
                            lien,
                            numeroReparation,
                            index: index + 1
                        });

                        console.log(`[Planner Script] üÜï Nouvelle t√¢che d√©tect√©e: ${numeroReparation}`);
                        ajouterOverlayTaskCard(taskCard, numeroReparation, 'üÜï Nouveau scan...');
                    }
                }
            }
        }
    });

    console.log(`[Planner Script] üìä BILAN FINAL: ${totalTasks} t√¢ches au total, ${alreadyProcessed} d√©j√† trait√©es, ${newTasks.length} nouvelles`);

    if (newTasks.length > 0) {
        // Scanner les nouvelles t√¢ches
        console.log(`[Planner Script] üöÄ Scan de ${newTasks.length} nouvelles t√¢ches...`);
        scanNewTasksAndProcess(newTasks);
    } else {
        console.log(`[Planner Script] ‚úÖ SCAN FINAL TERMIN√â: Aucune nouvelle t√¢che trouv√©e`);
        markScanAsCompletelyFinished();
    }
}

// Fonction pour scanner et traiter les nouvelles t√¢ches
function scanNewTasksAndProcess(newTasks) {
    let newPendingRequests = 0;
    const newTasksResults = new Map();

    // Scanner toutes les nouvelles t√¢ches en parall√®le
    newTasks.forEach((task, index) => {
        setTimeout(() => {
            const { lien, numeroReparation, taskCard } = task;
            newPendingRequests++;

            GM_xmlhttpRequest({
                method: 'GET',
                url: lien,
                onload: function (response) {
                    newPendingRequests--;

                    let texteLabel = 'Erreur';
                    let canMove = false;
                    let canComplete = false;

                    if (response.status === 200) {
                        const html = response.responseText;
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');

                        const label = doc.querySelector('span.label-success');
                        texteLabel = label?.textContent?.trim() || 'non trouv√©';

                        if (texteLabel === 'non trouv√©' && response.finalUrl?.includes('/Prm/AfficherPv/')) {
                            texteLabel = 'Termin√© / PV';
                        }

                        const autoListFinish = getList();
                        const matchInList = autoListFinish.some(item => texteLabel.includes(item));
                        const containsPieceEnProd = texteLabel.includes('PIECE EN PROD');
                        canMove = !containsPieceEnProd && !matchInList;
                        canComplete = matchInList && !containsPieceEnProd;
                    }

                    // Stocker dans les r√©sultats globaux ET locaux
                    const result = {
                        texteLabel,
                        canMove,
                        canComplete,
                        taskCard,
                        originalContainer: task.container
                    };

                    tasksResults.set(numeroReparation, result);
                    newTasksResults.set(numeroReparation, result);

                    // Mettre √† jour l'overlay
                    const overlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
                    if (overlay) {
                        const textElement = overlay.querySelector('.text-collector');
                        if (textElement) {
                            if (canComplete) {
                                textElement.textContent = '‚úÖ ' + texteLabel;
                                overlay.style.backgroundColor = 'rgba(0, 0, 255, 0.8)';
                            } else if (canMove) {
                                textElement.textContent = 'üöÄ ' + texteLabel;
                                overlay.style.backgroundColor = 'rgba(0, 255, 0, 0.8)';
                            } else {
                                textElement.textContent = '‚è∏Ô∏è ' + texteLabel;
                                overlay.style.backgroundColor = 'rgba(128, 128, 128, 0.8)';
                            }
                        }
                    }

                    console.log(`[Planner Script] ‚úÖ Nouvelle t√¢che scann√©e ${numeroReparation}: ${texteLabel}`);

                    // V√©rifier si tous les scans sont termin√©s
                    if (newPendingRequests === 0) {
                        processNewTasksActions(newTasksResults);
                    }
                },
                onerror: function () {
                    newPendingRequests--;
                    console.log(`[Planner Script] ‚ùå Erreur scan nouvelle t√¢che ${numeroReparation}`);

                    if (newPendingRequests === 0) {
                        processNewTasksActions(newTasksResults);
                    }
                }
            });
        }, index * 100); // 100ms entre chaque requ√™te
    });
}

// Fonction pour traiter les actions sur les nouvelles t√¢ches
function processNewTasksActions(newTasksResults) {
    const newMovableTasks = Array.from(newTasksResults.entries()).filter(([_, result]) => result.canMove);
    const newCompletableTasks = Array.from(newTasksResults.entries()).filter(([_, result]) => result.canComplete);

    console.log(`[Planner Script] üéØ NOUVELLES T√ÇCHES: ${newCompletableTasks.length} √† cocher, ${newMovableTasks.length} √† d√©placer`);

    if (newCompletableTasks.length > 0 || newMovableTasks.length > 0) {
        // Traiter les nouvelles t√¢ches avec le m√™me syst√®me que les anciennes
        if (newCompletableTasks.length > 0) {
            console.log(`[Planner Script] ‚úÖ Cochage des ${newCompletableTasks.length} nouvelles t√¢ches termin√©es...`);
            setTimeout(() => {
                startSimplifiedCompletions(newCompletableTasks, newMovableTasks);
            }, 2000);
        } else if (newMovableTasks.length > 0) {
            console.log(`[Planner Script] üöÄ D√©placement des ${newMovableTasks.length} nouvelles t√¢ches...`);
            setTimeout(() => {
                startSimplifiedMovements(newMovableTasks);
            }, 2000);
        }

        // Apr√®s le traitement, finaliser compl√®tement
        const totalNewActions = newCompletableTasks.length + newMovableTasks.length;
        setTimeout(() => {
            markScanAsCompletelyFinished();
        }, totalNewActions * 4000 + 5000); // Temps estim√© pour toutes les actions + marge
    } else {
        markScanAsCompletelyFinished();
    }
}

// Fonction pour marquer le scan comme compl√®tement termin√©
function markScanAsCompletelyFinished() {
    console.log(`[Planner Script] üèÜ SCAN COMPL√àTEMENT TERMIN√â!`);
    console.log(`[Planner Script] üìä TOTAL FINAL: ${tasksResults.size} t√¢ches trait√©es`);
    console.log(`[Planner Script] ‚úÖ Toutes les t√¢ches ont √©t√© scann√©es, coch√©es et d√©plac√©es selon les r√®gles`);
    console.log(`[Planner Script] üéâ Le processus de scan automatique est maintenant COMPL√àTEMENT FINI!`);

    // Marquer le scan comme termin√©
    scanInProgress = false;

    // Remettre imm√©diatement le bouton √† l'√©tat pr√™t pour un nouveau scan
    if (typeof resetButtonToReady === 'function') {
        resetButtonToReady();
        console.log(`[Planner Script] üîò Bouton remis √† l'√©tat pr√™t pour un nouveau scan`);
    }

    // Derni√®re restauration des overlays pour s'assurer que tout est visible
    setTimeout(() => {
        restoreAllOverlays();
        console.log(`[Planner Script] üé® Restauration finale de tous les overlays effectu√©e`);

        // Message final tr√®s visible pour indiquer que l'utilisateur peut relancer
        displayFinalCompletionMessage();

        // S'assurer une derni√®re fois que le bouton est pr√™t
        if (typeof resetButtonToReady === 'function') {
            resetButtonToReady();
        }
    }, 2000);
}

// Fonction pour afficher un message final tr√®s visible
function displayFinalCompletionMessage() {
    console.log(`%c
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üéâ SCAN TERMIN√â ! üéâ                      ‚ïë
‚ïë                                                               ‚ïë
‚ïë   ‚úÖ Toutes les t√¢ches ont √©t√© trait√©es                      ‚ïë
‚ïë   ‚úÖ Les overlays sont visibles                              ‚ïë
‚ïë   ‚úÖ Le bouton SCAN est pr√™t pour un nouveau lancement       ‚ïë
‚ïë                                                               ‚ïë
‚ïë   üîÑ CLIQUEZ √Ä NOUVEAU SUR LE BOUTON SCAN POUR RELANCER     ‚ïë
‚ïë                                                               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `, 'color: #00ff00; font-weight: bold; font-size: 14px;');

    console.log(`[Planner Script] üéØ PR√äT POUR RELANCE: Vous pouvez maintenant cliquer sur le bouton SCAN`);
    console.log(`[Planner Script] üîÑ Le nouveau cycle fera: Scroll ‚Üí Scan ‚Üí Cochages ‚Üí D√©placements ‚Üí Scan Final`);

    // Ajouter un petit effet visuel sur le bouton pour indiquer qu'il est pr√™t
    if (typeof window.scrollButton !== 'undefined' && window.scrollButton) {
        const button = window.scrollButton;

        // Effet de pulsation plus visible
        button.style.animation = 'pulse 1.5s ease-in-out infinite';

        // Message au survol
        button.title = 'Cliquez pour relancer un nouveau scan complet';

        // Arr√™ter l'animation apr√®s 10 secondes
        setTimeout(() => {
            if (button) {
                button.style.animation = '';
            }
        }, 10000);
    }
}

// Fonction pour traiter tous les conteneurs rapidement (ANCIENNE VERSION - gard√©e pour compatibilit√©)
function processAllContainersRapidly() {
    // Chercher les conteneurs avec priorit√© : listBoxGroup d'abord, puis taskBoardCard
    let containers = document.querySelectorAll('.listBoxGroup .taskBoardCard');

    if (containers.length === 0) {
        containers = document.querySelectorAll('.taskBoardCard');
    }

    if (containers.length === 0) {
        console.log('[Planner Script] ‚ùå Aucun conteneur trouv√© pour le traitement rapide');
        return;
    }

    console.log(`[Planner Script] ‚ö° Traitement rapide de ${containers.length} conteneurs`);

    containers.forEach((container, index) => {
        const containerNumber = index + 1;
        console.log(`[Planner Script] Traitement rapide du conteneur ${containerNumber}`);

        const taskCard = container.querySelector('div.taskCard');
        if (!taskCard) {
            console.log(`[Planner Script] Pas de taskCard dans le conteneur ${containerNumber}`);
            return;
        }

        const lienElement = container.querySelector('a.referencePreviewDescription');
        let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');
        console.log(`[Planner Script] Lien trouv√© pour le conteneur ${containerNumber}:`, lien);

        if (lien && !lien.endsWith('.html')) lien += '.html';
        if (!lien || !lien.includes('.html')) {
            console.log(`[Planner Script] Lien invalide pour le conteneur ${containerNumber}, ignor√©`);
            return;
        }

        const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1] || 'inconnu';

        // V√©rifier si cette t√¢che a d√©j√† √©t√© trait√©e
        if (processedTasks.has(numeroReparation)) {
            console.log(`[Planner Script] ‚ö†Ô∏è T√¢che ${numeroReparation} d√©j√† trait√©e, ignor√©e`);
            return;
        }

        console.log(`[Planner Script] Num√©ro de r√©paration: ${numeroReparation}`);
        processedTasks.add(numeroReparation);

        ajouterOverlayTaskCard(taskCard, numeroReparation, 'Chargement...');
        testerLienHttp(lien, taskCard);
    });

    // Marquer la fin du scan initial et d√©marrer le nouveau syst√®me
    setTimeout(() => {
        console.log('[Planner Script] ‚úÖ Scan rapide initial termin√© - D√âMARRAGE NOUVEAU SYST√àME');
        startNewScanSystem();
    }, 1000);
}

// NOUVEAU SYST√àME: Scan complet d'abord, puis d√©placements
function startNewScanSystem() {
    // Chercher les conteneurs avec priorit√© : listBoxGroup d'abord, puis taskBoardCard
    let containers = document.querySelectorAll('.listBoxGroup .taskBoardCard');

    if (containers.length === 0) {
        containers = document.querySelectorAll('.taskBoardCard');
    }

    if (containers.length === 0) {
        console.log('[Planner Script] ‚ùå Aucun conteneur trouv√© pour le nouveau syst√®me');
        return;
    }

    console.log(`[Planner Script] üîç NOUVEAU SYST√àME - PHASE 1: Scan de ${containers.length} conteneurs (SANS d√©placements)`);

    // R√©initialiser les variables
    tasksToScan = [];
    tasksResults.clear();
    pendingRequests = 0;

    // Pr√©parer la liste des t√¢ches √† scanner
    containers.forEach((container, index) => {
        const containerNumber = index + 1;

        const taskCard = container.querySelector('div.taskCard');
        if (!taskCard) {
            return;
        }

        const lienElement = container.querySelector('a.referencePreviewDescription');
        let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

        if (lien && !lien.endsWith('.html')) lien += '.html';
        if (!lien || !lien.includes('.html')) {
            return;
        }

        const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1] || 'inconnu';

        // V√©rifier si cette t√¢che a d√©j√† √©t√© trait√©e par l'ancien syst√®me
        if (processedTasks.has(numeroReparation)) {
            console.log(`[Planner Script] ‚ö†Ô∏è T√¢che ${numeroReparation} d√©j√† trait√©e par l'ancien syst√®me, on la reprend`);
            // On la reprend quand m√™me pour le nouveau syst√®me
        }

        // Ajouter l'overlay de scanning pour le nouveau syst√®me
        ajouterOverlayTaskCard(taskCard, numeroReparation, 'üîç Analyse...');

        // Ajouter √† la liste des t√¢ches √† scanner
        tasksToScan.push({
            container,
            taskCard,
            lien,
            numeroReparation,
            containerNumber
        });
    });

    console.log(`[Planner Script] üìã ${tasksToScan.length} t√¢ches pr√©par√©es pour le nouveau scan`);

    if (tasksToScan.length > 0) {
        // Lancer le scan de toutes les t√¢ches
        startBatchScanning();
    }
}

// Fonction pour scanner par lots sans d√©placer
function startBatchScanning() {
    console.log(`[Planner Script] üöÄ D√©marrage du scan par lots (max ${maxConcurrentRequests} simultan√©s)`);

    // Traiter les t√¢ches par petits lots
    tasksToScan.forEach((task, index) => {
        // Limiter le nombre de requ√™tes simultan√©es
        setTimeout(() => {
            scanTaskOnly(task);
        }, Math.floor(index / maxConcurrentRequests) * 1000); // 1 seconde entre chaque lot
    });
}

// Fonction pour scanner une t√¢che uniquement (sans d√©placement)
function scanTaskOnly(task) {
    const { container, taskCard, lien, numeroReparation, containerNumber } = task;

    console.log(`[Planner Script] üîç Scan de la t√¢che ${numeroReparation}...`);
    pendingRequests++;

    GM_xmlhttpRequest({
        method: 'GET',
        url: lien,
        onload: function (response) {
            handleScanResult(response, task);
        },
        onerror: function () {
            console.log(`[Planner Script] ‚ùå Erreur scan pour ${numeroReparation}`);
            pendingRequests--;
            checkScanCompletion();
        }
    });
}

// Fonction pour traiter le r√©sultat d'un scan
function handleScanResult(response, task) {
    const { container, taskCard, lien, numeroReparation } = task;
    pendingRequests--;

    if (response.status === 200) {
        const html = response.responseText;
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        const label = doc.querySelector('span.label-success');
        let texteLabel = label?.textContent?.trim() || 'non trouv√©';

        // Traiter le cas PV
        if (texteLabel === 'non trouv√©' && response.finalUrl?.includes('/Prm/AfficherPv/')) {
            texteLabel = 'Termin√© / PV';
        }

        // Stocker le r√©sultat
        tasksResults.set(numeroReparation, {
            container,
            taskCard,
            texteLabel,
            lien,
            canMove: shouldMoveTask(texteLabel),
            canComplete: shouldCompleteTask(texteLabel)
        });

        // Mettre √† jour l'overlay avec le statut
        const overlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
        if (overlay) {
            const textElement = overlay.querySelector('.text-collector');
            if (textElement) {
                textElement.textContent = texteLabel;

                // Colorer selon le r√©sultat
                if (shouldMoveTask(texteLabel)) {
                    overlay.style.backgroundColor = 'rgba(0, 255, 0, 0.8)'; // Vert pour d√©placement
                    textElement.textContent = 'üöÄ ' + texteLabel;
                } else if (shouldCompleteTask(texteLabel)) {
                    overlay.style.backgroundColor = 'rgba(0, 0, 255, 0.8)'; // Bleu pour completion
                    textElement.textContent = '‚úÖ ' + texteLabel;
                } else {
                    overlay.style.backgroundColor = 'rgba(128, 128, 128, 0.8)'; // Gris pour aucune action
                    textElement.textContent = '‚è∏Ô∏è ' + texteLabel;
                }
            }
        }

        console.log(`[Planner Script] ‚úÖ Scan termin√© pour ${numeroReparation}: "${texteLabel}"`);
    } else {
        console.log(`[Planner Script] ‚ùå Erreur ${response.status} pour ${numeroReparation}`);
    }

    checkScanCompletion();
}

// V√©rifier si le scan est termin√© et lancer les d√©placements
function checkScanCompletion() {
    if (pendingRequests === 0) {
        console.log(`[Planner Script] üéâ PHASE 1 TERMIN√âE: Tous les scans sont termin√©s!`);
        console.log(`[Planner Script] üìä ${tasksResults.size} t√¢ches analys√©es`);

        // Afficher un r√©sum√© des actions pr√©vues
        let movesToDo = 0;
        let completionsToDoCount = 0;

        tasksResults.forEach((result, numeroReparation) => {
            if (result.canMove) movesToDo++;
            if (result.canComplete) completionsToDoCount++;
        });

        console.log(`[Planner Script] üìã Actions pr√©vues: ${movesToDo} d√©placements, ${completionsToDoCount} compl√©tions`);

        // Arr√™ter la surveillance DOM avant les d√©placements pour √©viter les interf√©rences
        if (domWatcher) {
            console.log('[Planner Script] üõë Arr√™t de la surveillance DOM avant la phase de d√©placement');
            domWatcher.disconnect();
            domWatcher = null;
        }

        // Lancer les d√©placements apr√®s un d√©lai
        setTimeout(() => {
            startMovementPhase();
        }, 3000);
    } else {
        console.log(`[Planner Script] ‚è≥ ${pendingRequests} scans en cours...`);
    }
}

// Phase 2: Effectuer les d√©placements
function startMovementPhase() {
    console.log(`[Planner Script] üöÄ PHASE 2: D√©marrage des d√©placements...`);

    let movementsCount = 0;
    let completionsCount = 0;

    // Convertir en array pour un traitement s√©quentiel
    const tasksArray = Array.from(tasksResults.entries());

    // Traiter les d√©placements un par un
    tasksArray.forEach(([numeroReparation, result], index) => {
        const { texteLabel, canMove, canComplete } = result;

        // Effectuer les d√©placements avec des d√©lais
        if (canMove) {
            setTimeout(async () => {
                console.log(`[Planner Script] üöÄ D√©placement ${movementsCount + 1}/${tasksArray.filter(([_, r]) => r.canMove).length}: ${numeroReparation} (${texteLabel})`);

                // CRUCIAL: Rechercher √† nouveau l'√©l√©ment DOM au moment du d√©placement
                const currentTaskCard = await findCurrentTaskCard(numeroReparation);
                if (currentTaskCard) {
                    tryMoveTaskToDropZone(currentTaskCard, numeroReparation, texteLabel);
                } else {
                    console.log(`[Planner Script] ‚ùå Impossible de trouver la t√¢che ${numeroReparation} pour le d√©placement`);
                }
            }, movementsCount * 6000); // 6 secondes entre chaque d√©placement (plus de temps)
            movementsCount++;
        }

        // Effectuer les compl√©tions avec des d√©lais
        if (canComplete) {
            setTimeout(async () => {
                console.log(`[Planner Script] ‚úÖ Completion ${completionsCount + 1}: ${numeroReparation} (${texteLabel})`);

                // CRUCIAL: Rechercher √† nouveau l'√©l√©ment DOM au moment de la completion
                const currentTaskCard = await findCurrentTaskCard(numeroReparation);
                if (currentTaskCard) {
                    tryClickComplete(currentTaskCard, numeroReparation, texteLabel);
                } else {
                    console.log(`[Planner Script] ‚ùå Impossible de trouver la t√¢che ${numeroReparation} pour la completion`);
                }
            }, (movementsCount * 6000) + (completionsCount * 2000)); // Apr√®s les d√©placements
            completionsCount++;
        }
    });

    console.log(`[Planner Script] üìã Programme: ${movementsCount} d√©placements, ${completionsCount} compl√©tions`);
}

// Fonction pour retrouver une taskCard par son num√©ro de r√©paration
function findCurrentTaskCard(numeroReparation) {
    console.log(`[Planner Script] üîç Recherche de la t√¢che ${numeroReparation} dans le DOM actuel...`);

    // Petite attente pour laisser le DOM se stabiliser
    return new Promise((resolve) => {
        setTimeout(() => {
            // Chercher d'abord dans les colonnes prioritaires (listBoxGroup)
            let allContainers = document.querySelectorAll('.listBoxGroup .taskBoardCard');

            // Si rien trouv√©, chercher dans tous les conteneurs
            if (allContainers.length === 0) {
                allContainers = document.querySelectorAll('.taskBoardCard');
            }

            console.log(`[Planner Script] üîç Examen de ${allContainers.length} conteneurs pour trouver ${numeroReparation}...`);

            for (const container of allContainers) {
                const lienElement = container.querySelector('a.referencePreviewDescription');
                let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

                if (lien) {
                    if (!lien.endsWith('.html')) lien += '.html';
                    const foundNumero = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];

                    if (foundNumero === numeroReparation) {
                        const taskCard = container.querySelector('div.taskCard');
                        if (taskCard) {
                            console.log(`[Planner Script] ‚úÖ T√¢che ${numeroReparation} trouv√©e dans le DOM actuel`);

                            // V√©rifier dans quelle colonne elle se trouve
                            const parentColumn = container.closest('.listBoxGroup');
                            if (parentColumn) {
                                const columnHeader = parentColumn.querySelector('[data-automation-id="task-bucket-header"]');
                                const columnName = columnHeader?.textContent?.trim() || 'Colonne inconnue';
                                console.log(`[Planner Script] üìç T√¢che ${numeroReparation} trouv√©e dans la colonne: ${columnName}`);
                            }

                            resolve(taskCard);
                            return;
                        } else {
                            console.log(`[Planner Script] ‚ö†Ô∏è Conteneur trouv√© pour ${numeroReparation} mais pas de taskCard`);
                        }
                    }
                }
            }

            console.log(`[Planner Script] ‚ùå T√¢che ${numeroReparation} non trouv√©e dans le DOM actuel`);
            resolve(null);
        }, 500); // 500ms pour laisser le DOM se stabiliser
    });
}

// Fonctions utilitaires pour d√©terminer les actions
function shouldMoveTask(texteLabel) {
    const autoListFinish = getList();
    const matchInList = autoListFinish.some(item => texteLabel.includes(item));
    const containsPieceEnProd = texteLabel.includes('PIECE EN PROD');

    return !containsPieceEnProd && !matchInList;
}

function shouldCompleteTask(texteLabel) {
    const completionList = [
        'ELECTRONIQUE - 01 - LIVRAISON EFFECTUEE',
        'ELECTRONIQUE - 02 - DEMANDE TRAITEE',
        'ELECTRONIQUE - 03 - REX TERMINE',
        'MECANIQUE - 12 - LIVRAISON EFFECTUEE',
        'MECANIQUE - 13 - DEMANDE TRAITEE',
        'MECANIQUE - 14 - REX TERMINE',
        'Termin√© / PV'
    ];

    return completionList.some(item => texteLabel.includes(item));
}

// Fonction de surveillance DOM pour g√©rer les changements apr√®s d√©placement
function startDOMWatcher() {
    if (domWatcher) {
        domWatcher.disconnect();
    }

    console.log('[Planner Script] üëÅÔ∏è D√©marrage de la surveillance DOM');

    let scanTimeout = null;
    let lastScanTime = 0;
    let changeMutationCount = 0;

    domWatcher = new MutationObserver((mutations) => {
        let hasSignificantChanges = false;
        let taskCardChanges = 0;

        mutations.forEach((mutation) => {
            if (mutation.type === 'childList') {
                // Compter les changements de t√¢ches uniquement
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const isTaskCard = node.classList && node.classList.contains('taskBoardCard');
                        const hasTaskCards = node.querySelectorAll && node.querySelectorAll('.taskBoardCard').length > 0;

                        if (isTaskCard || hasTaskCards) {
                            taskCardChanges++;
                            hasSignificantChanges = true;
                        }
                    }
                });

                mutation.removedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE && node.classList) {
                        if (node.classList.contains('taskBoardCard')) {
                            taskCardChanges++;
                            hasSignificantChanges = true;
                        }
                    }
                });
            }
        });

        if (hasSignificantChanges && taskCardChanges > 0) {
            changeMutationCount++;
            console.log(`[Planner Script] ÔøΩ Changement d√©tect√©: ${taskCardChanges} t√¢che(s) affect√©e(s) (mutation #${changeMutationCount})`);

            // √âviter les scans trop fr√©quents
            const now = Date.now();
            if (now - lastScanTime < 5000) {
                console.log('[Planner Script] ‚è≥ Scan trop r√©cent, attente...');
                return;
            }

            // Annuler le timeout pr√©c√©dent
            if (scanTimeout) {
                clearTimeout(scanTimeout);
            }

            // Programmer un nouveau scan seulement si n√©cessaire
            scanTimeout = setTimeout(() => {
                // V√©rifier s'il y a vraiment de nouvelles t√¢ches √† traiter
                const currentTasks = document.querySelectorAll('.taskBoardCard');
                let newTasksFound = 0;

                currentTasks.forEach((container) => {
                    const lienElement = container.querySelector('a.referencePreviewDescription');
                    let lien = lienElement?.getAttribute('href') || lienElement?.getAttribute('title');

                    if (lien) {
                        if (lien && !lien.endsWith('.html')) lien += '.html';
                        const numeroReparation = lien.match(/\/(\d+)(?:\.html)?$/)?.[1];

                        if (numeroReparation && !processedTasks.has(numeroReparation)) {
                            newTasksFound++;
                        }
                    }
                });

                if (newTasksFound > 0) {
                    console.log(`[Planner Script] üÜï ${newTasksFound} nouvelle(s) t√¢che(s) trouv√©e(s), lancement du scan...`);
                    lastScanTime = Date.now();
                    processAllContainersRapidly();
                } else {
                    console.log('[Planner Script] ‚ÑπÔ∏è Aucune nouvelle t√¢che trouv√©e, scan ignor√©');
                }
            }, 4000); // D√©lai plus long pour √©viter les scans inutiles
        }
    });

    // Observer tout le document pour capter les changements
    domWatcher.observe(document.body, {
        childList: true,
        subtree: true
    });

    // Arr√™ter la surveillance apr√®s 60 secondes avec rapport final
    setTimeout(() => {
        if (domWatcher) {
            domWatcher.disconnect();
            domWatcher = null;
            scanInProgress = false;
            console.log(`[Planner Script] üõë Surveillance DOM arr√™t√©e apr√®s 60 secondes`);
            console.log(`[Planner Script] üìä R√©sum√©: ${processedTasks.size} t√¢ches trait√©es au total, ${changeMutationCount} changements d√©tect√©s`);
        }
        if (scanTimeout) {
            clearTimeout(scanTimeout);
        }
    }, 60000);
}

// Fonction pour arr√™ter la surveillance DOM si n√©cessaire
function stopDOMWatcher() {
    if (domWatcher) {
        domWatcher.disconnect();
        domWatcher = null;
        scanInProgress = false;
        console.log('[Planner Script] ÔøΩ Surveillance DOM arr√™t√©e manuellement');
    }
}

// Fonction de diagnostic pour v√©rifier la d√©tection de la nouvelle structure
function diagnosticStructure() {
    console.log('=== DIAGNOSTIC DE STRUCTURE DOM ===');

    // V√©rifier les listBoxGroup (structure apr√®s d√©placement - NOUVEAU)
    const listBoxGroups = document.querySelectorAll('.listBoxGroup');
    console.log(`üéØ Nombre de listBoxGroup trouv√©es: ${listBoxGroups.length}`);
    listBoxGroups.forEach((group, index) => {
        console.log(`- listBoxGroup ${index + 1}:`, group.className, group);
        const parent = group.parentElement;
        if (parent && parent.classList.contains('taskBoardColumnGroup')) {
            console.log(`  ‚îî‚îÄ Parent taskBoardColumnGroup:`, parent.className);
        }
        // Compter les t√¢ches dans ce groupe
        const tasksInGroup = group.querySelectorAll('.taskBoardCard');
        console.log(`  ‚îî‚îÄ T√¢ches dans ce groupe: ${tasksInGroup.length}`);
    });

    // V√©rifier les listWrapper (zone de drop principale)
    const listWrappers = document.querySelectorAll('.listWrapper');
    console.log(`Nombre de listWrapper trouv√©es: ${listWrappers.length}`);
    listWrappers.forEach((wrapper, index) => {
        console.log(`- listWrapper ${index + 1}:`, wrapper.className, wrapper);
        const parent = wrapper.parentElement;
        if (parent && parent.classList.contains('taskBoardColumnGroup')) {
            console.log(`  ‚îî‚îÄ Parent taskBoardColumnGroup:`, parent.className);
        }
    });

    // V√©rifier les bottomDropZone (zone de drop secondaire)
    const bottomDropZones = document.querySelectorAll('.bottomDropZone');
    console.log(`Nombre de bottomDropZone trouv√©es: ${bottomDropZones.length}`);
    bottomDropZones.forEach((zone, index) => {
        console.log(`- bottomDropZone ${index + 1}:`, zone.className, zone);
    });

    // V√©rifier les taskBoardCard (conteneurs principaux des t√¢ches)
    const taskBoardCards = document.querySelectorAll('.taskBoardCard');
    console.log(`Nombre de taskBoardCard trouv√©es: ${taskBoardCards.length}`);
    taskBoardCards.forEach((card, index) => {
        if (index < 5) { // Limite l'affichage aux 5 premi√®res
            console.log(`- taskBoardCard ${index + 1}:`, card.className, card.id, card);
            const innerTaskCard = card.querySelector('.taskCard');
            if (innerTaskCard) {
                console.log(`  ‚îî‚îÄ taskCard interne:`, innerTaskCard.className);
            }
        }
    });

    // V√©rifier les taskCard internes
    const taskCards = document.querySelectorAll('[class*="taskCard"]');
    console.log(`Nombre de taskCard trouv√©es: ${taskCards.length}`);

    // V√©rifier la colonne "En cours"
    const targetColumn = document.querySelector('#column_InProgress, li[id*="InProgress"], li[aria-label*="En cours"]');
    if (targetColumn) {
        console.log('Colonne "En cours" trouv√©e:', targetColumn.id || targetColumn.className, targetColumn);

        // V√©rifier la structure compl√®te
        const columnListBoxGroup = targetColumn.querySelector('.listBoxGroup');
        const columnListWrapper = targetColumn.querySelector('.listWrapper');
        const columnBottomDropZone = targetColumn.querySelector('.bottomDropZone');
        const columnTaskBoardGroup = targetColumn.querySelector('.taskBoardColumnGroup');

        if (columnListBoxGroup) {
            console.log('- üéØ ‚úÖ listBoxGroup dans la colonne "En cours" (OPTIMAL):', columnListBoxGroup.className, columnListBoxGroup);
            const tasksInListBoxGroup = columnListBoxGroup.querySelectorAll('.taskBoardCard');
            console.log(`  ‚îî‚îÄ T√¢ches dans listBoxGroup: ${tasksInListBoxGroup.length}`);
        } else {
            console.log('- ‚ùå Aucune listBoxGroup dans la colonne "En cours"');
        }

        if (columnListWrapper) {
            console.log('- ‚úÖ listWrapper dans la colonne "En cours":', columnListWrapper.className, columnListWrapper);
        } else {
            console.log('- ‚ùå Aucune listWrapper dans la colonne "En cours"');
        }

        if (columnBottomDropZone) {
            console.log('- ‚úÖ bottomDropZone dans la colonne "En cours":', columnBottomDropZone.className, columnBottomDropZone);
        } else {
            console.log('- ‚ùå Aucune bottomDropZone dans la colonne "En cours"');
        }

        if (columnTaskBoardGroup) {
            console.log('- ‚úÖ taskBoardColumnGroup dans la colonne "En cours":', columnTaskBoardGroup.className, columnTaskBoardGroup);
        } else {
            console.log('- ‚ùå Aucun taskBoardColumnGroup dans la colonne "En cours"');
        }
    } else {
        console.log('‚ùå Colonne "En cours" non trouv√©e');
    }

    console.log('=== FIN DIAGNOSTIC ===');
}

// Rendre les fonctions accessibles globalement
window.scanContainers = scanContainers;
window.diagnosticStructure = diagnosticStructure;
window.resetCompleteSystem = resetCompleteSystem;
window.startCompleteScrollAndScanCycle = startCompleteScrollAndScanCycle;
window.resetButtonToReady = resetButtonToReady;

function ajouterOverlayTaskCard(taskCard, numeroReparation, texteLabel = 'Chargement...') {
    const thumbnail = taskCard.querySelector('.thumbnail.placeholder');
    if (!thumbnail) return;

    // Supprime s'il existe d√©j√† (√©vite doublons) - recherche plus large
    const existingById = document.getElementById(`idreparation-status-${numeroReparation}`);
    if (existingById) existingById.remove();

    const existing = thumbnail.querySelector('.autoelement');
    if (existing) existing.remove();

    const container = document.createElement('div');
    container.className = 'autoelement';
    container.id = `idreparation-status-${numeroReparation}`;
    container.style.position = 'absolute';
    container.style.top = '50%';
    container.style.left = '50%';
    container.style.transform = 'translate(-50%, -50%)';
    container.style.zIndex = '10';
    container.style.borderRadius = '6px';
    container.style.padding = '5px 10px';
    container.style.fontSize = '12px';
    container.style.maxWidth = '160px';
    container.style.textAlign = 'center';

    container.innerHTML = `
        <div class="autoelement__img__container" style="text-align:center;">
            <img src="https://prod.cloud-collectorplus.mt.sncf.fr/assets/images/sprite_src/pictos/Collector_accueil.png"
                 alt="Icon"
                 class="autoelement__img__source"
                 style="width: 24px; height: 24px;">
        </div>
        <span class="autoelement__text text-numeroreparation" style="display:block; font-weight:bold; margin-top:4px;">
            ${numeroReparation}
        </span>
        <span class="autoelement__text text-collector" style="display:block; color: #333;">
            ${texteLabel}
        </span>
    `;

    thumbnail.style.position = 'relative';
    thumbnail.appendChild(container);

    // Ajuste dynamiquement la hauteur du thumbnail
    setTimeout(() => {
        const hauteurOverlay = container.scrollHeight;
        const hauteurMin = Math.max(hauteurOverlay + 20, 100);
        thumbnail.style.minHeight = hauteurMin + 'px';
    }, 0);
}

// Fonction qui v√©rifie si on doit cliquer sur le bouton "complete"
function tryClickComplete(taskCard, numeroReparation, texteLabel) {
    console.log(`[Planner Script] tryClickComplete appel√©e pour ${numeroReparation} avec statut: "${texteLabel}"`);

    const completeButton = taskCard.querySelector('.completeButtonWithAnimation');
    if (!completeButton) {
        console.log(`[Planner Script] Bouton complete non trouv√© pour ${numeroReparation}`);
        return;
    }

    if (completeButton.getAttribute('aria-checked') === 'true') {
        console.log(`[Planner Script] Bouton d√©j√† coch√© pour la t√¢che ${numeroReparation}, pas de clic`);
        return;
    }

    // Cas 1 : PV termin√©
    if (texteLabel === 'Termin√© / PV') {
        setTimeout(() => {
            completeButton.click();
            console.log(`[Planner Script] ‚úÖ Bouton complete cliqu√© (PV) pour la t√¢che ${numeroReparation}`);
        }, 500);
        return;
    }

    // Cas 2 : correspond √† un √©l√©ment de la liste
    const autoListFinish = getList();
    const match = autoListFinish.some(item => texteLabel.includes(item));
    if (match) {
        setTimeout(() => {
            completeButton.click();
            console.log(`[Planner Script] ‚úÖ Bouton complete cliqu√© (liste match: "${texteLabel}") pour la t√¢che ${numeroReparation}`);
        }, 500);
    } else {
        console.log(`[Planner Script] Statut "${texteLabel}" ne correspond pas aux crit√®res de completion pour ${numeroReparation}`);
    }
}

// Fonction pour simuler un vrai drag & drop avec tous les √©v√©nements n√©cessaires
function simulateDragAndDrop(sourceElement, targetElement) {
    try {
        console.log(`[Planner Script] üé¨ Simulation du drag & drop depuis:`, sourceElement);
        console.log(`[Planner Script] üéØ Vers la cible:`, targetElement);

        // V√©rifier que les √©l√©ments sont visibles
        const sourceRect = sourceElement.getBoundingClientRect();
        const targetRect = targetElement.getBoundingClientRect();

        console.log(`[Planner Script] Source rect:`, sourceRect);
        console.log(`[Planner Script] Target rect:`, targetRect);

        // Si l'√©l√©ment source n'est pas visible, le faire d√©filer dans la vue
        if (sourceRect.top < 0 || sourceRect.bottom > window.innerHeight) {
            console.log(`[Planner Script] üìú √âl√©ment source hors de vue, d√©filement...`);
            sourceElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Attendre que le d√©filement soit termin√©
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve(simulateDragAndDrop(sourceElement, targetElement));
                }, 1000);
            });
        }

        const sourceCenter = {
            x: sourceRect.left + sourceRect.width / 2,
            y: sourceRect.top + sourceRect.height / 2
        };

        const targetCenter = {
            x: targetRect.left + targetRect.width / 2,
            y: targetRect.top + targetRect.height / 2
        };

        console.log(`[Planner Script] Source position:`, sourceCenter);
        console.log(`[Planner Script] Target position:`, targetCenter);

        // Essayer d'abord avec un d√©placement DOM direct puis des √©v√©nements
        console.log(`[Planner Script] üîÑ Tentative de d√©placement DOM direct...`);

        // M√©moriser la position originale
        const originalParent = sourceElement.parentElement;
        const originalNextSibling = sourceElement.nextElementSibling;

        // D√©placer physiquement l'√©l√©ment
        targetElement.appendChild(sourceElement);

        // V√©rifier si le d√©placement a pris effet
        if (sourceElement.parentElement === targetElement) {
            console.log(`[Planner Script] ‚úÖ D√©placement DOM direct r√©ussi`);

            // D√©clencher les √©v√©nements pour notifier l'application
            setTimeout(() => {
                // √âv√©nements de drag & drop pour la coh√©rence
                const dragStartEvent = new DragEvent('dragstart', {
                    bubbles: true,
                    cancelable: true,
                    clientX: sourceCenter.x,
                    clientY: sourceCenter.y
                });
                sourceElement.dispatchEvent(dragStartEvent);

                const dropEvent = new DragEvent('drop', {
                    bubbles: true,
                    cancelable: true,
                    clientX: targetCenter.x,
                    clientY: targetCenter.y
                });
                targetElement.dispatchEvent(dropEvent);

                // √âv√©nements de mutation pour React
                const mutationEvent = new CustomEvent('taskMoved', {
                    bubbles: true,
                    detail: {
                        taskId: sourceElement.id,
                        source: originalParent,
                        target: targetElement,
                        type: 'manual-move'
                    }
                });

                document.dispatchEvent(mutationEvent);
                targetElement.dispatchEvent(new Event('DOMNodeInserted', { bubbles: true }));
                sourceElement.dispatchEvent(new Event('DOMNodeMoved', { bubbles: true }));

                console.log(`[Planner Script] ‚úÖ √âv√©nements de notification envoy√©s`);
            }, 100);

            return true;
        } else {
            console.log(`[Planner Script] ‚ùå D√©placement DOM direct √©chou√©, fallback vers √©v√©nements`);

            // Remettre √† la position originale
            if (originalNextSibling) {
                originalParent.insertBefore(sourceElement, originalNextSibling);
            } else {
                originalParent.appendChild(sourceElement);
            }

            // Fallback vers la simulation d'√©v√©nements
            return simulateMouseDragAndDrop(sourceElement, targetElement);
        }

    } catch (error) {
        console.error(`[Planner Script] ‚ùå Erreur lors de la simulation du drag & drop:`, error);
        return simulateMouseDragAndDrop(sourceElement, targetElement);
    }
}

// Fonction de fallback utilisant des √©v√©nements de souris
function simulateMouseDragAndDrop(sourceElement, targetElement) {
    try {
        const sourceRect = sourceElement.getBoundingClientRect();
        const targetRect = targetElement.getBoundingClientRect();

        const sourceCenter = {
            x: sourceRect.left + sourceRect.width / 2,
            y: sourceRect.top + sourceRect.height / 2
        };

        const targetCenter = {
            x: targetRect.left + targetRect.width / 2,
            y: targetRect.top + targetRect.height / 2
        };

        // 1. mousedown sur l'√©l√©ment source
        const mouseDownEvent = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            clientX: sourceCenter.x,
            clientY: sourceCenter.y,
            button: 0
        });
        sourceElement.dispatchEvent(mouseDownEvent);
        console.log(`[Planner Script] ‚úÖ mousedown event dispatched`);

        // 2. mousemove pour simuler le drag
        setTimeout(() => {
            const mouseMoveEvent = new MouseEvent('mousemove', {
                bubbles: true,
                cancelable: true,
                clientX: targetCenter.x,
                clientY: targetCenter.y,
                button: 0
            });
            document.dispatchEvent(mouseMoveEvent);
            console.log(`[Planner Script] ‚úÖ mousemove event dispatched`);

            // 3. mouseup sur la cible
            setTimeout(() => {
                const mouseUpEvent = new MouseEvent('mouseup', {
                    bubbles: true,
                    cancelable: true,
                    clientX: targetCenter.x,
                    clientY: targetCenter.y,
                    button: 0
                });
                targetElement.dispatchEvent(mouseUpEvent);
                console.log(`[Planner Script] ‚úÖ mouseup event dispatched`);

                // 4. click sur la cible pour finaliser
                setTimeout(() => {
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        clientX: targetCenter.x,
                        clientY: targetCenter.y,
                        button: 0
                    });
                    targetElement.dispatchEvent(clickEvent);
                    console.log(`[Planner Script] ‚úÖ click event dispatched`);
                }, 50);
            }, 100);
        }, 50);

        return true;

    } catch (error) {
        console.error(`[Planner Script] ‚ùå Erreur lors de la simulation des √©v√©nements de souris:`, error);
        return false;
    }
}

// Fonction alternative utilisant une approche plus programatique
function simulateNativeDragAndDrop(sourceElement, targetElement) {
    try {
        console.log(`[Planner Script] üîß Tentative de drag & drop natif programm√©`);

        // V√©rifier si l'√©l√©ment source a les bons attributs
        if (!sourceElement.draggable) {
            sourceElement.draggable = true;
            console.log(`[Planner Script] ‚úÖ √âl√©ment source rendu draggable`);
        }

        // Cr√©er un DataTransfer personnalis√©
        const dataTransfer = new DataTransfer();
        dataTransfer.setData('text/plain', sourceElement.id || 'task');
        dataTransfer.effectAllowed = 'move';

        // Positions pour les √©v√©nements
        const sourceRect = sourceElement.getBoundingClientRect();
        const targetRect = targetElement.getBoundingClientRect();

        const sourceCenter = {
            x: sourceRect.left + sourceRect.width / 2,
            y: sourceRect.top + sourceRect.height / 2
        };

        const targetCenter = {
            x: targetRect.left + targetRect.width / 2,
            y: targetRect.top + targetRect.height / 2
        };

        // S√©quence d'√©v√©nements avec d√©lais
        return new Promise((resolve) => {
            let step = 0;

            const executeStep = () => {
                try {
                    switch(step) {
                        case 0:
                            // Focus sur l'√©l√©ment source
                            sourceElement.focus();
                            console.log(`[Planner Script] ‚úÖ √âtape ${step}: focus sur source`);
                            break;

                        case 1:
                            // dragstart
                            const dragStartEvent = new DragEvent('dragstart', {
                                bubbles: true,
                                cancelable: true,
                                clientX: sourceCenter.x,
                                clientY: sourceCenter.y,
                                dataTransfer: dataTransfer
                            });

                            sourceElement.dispatchEvent(dragStartEvent);
                            console.log(`[Planner Script] ‚úÖ √âtape ${step}: dragstart`);
                            break;

                        case 2:
                            // dragenter sur target
                            const dragEnterEvent = new DragEvent('dragenter', {
                                bubbles: true,
                                cancelable: true,
                                clientX: targetCenter.x,
                                clientY: targetCenter.y,
                                dataTransfer: dataTransfer
                            });

                            dragEnterEvent.preventDefault = () => {};
                            targetElement.dispatchEvent(dragEnterEvent);
                            console.log(`[Planner Script] ‚úÖ √âtape ${step}: dragenter`);
                            break;

                        case 3:
                            // dragover sur target
                            const dragOverEvent = new DragEvent('dragover', {
                                bubbles: true,
                                cancelable: true,
                                clientX: targetCenter.x,
                                clientY: targetCenter.y,
                                dataTransfer: dataTransfer
                            });

                            dragOverEvent.preventDefault = () => {};
                            targetElement.dispatchEvent(dragOverEvent);
                            console.log(`[Planner Script] ‚úÖ √âtape ${step}: dragover`);
                            break;

                        case 4:
                            // drop sur target
                            const dropEvent = new DragEvent('drop', {
                                bubbles: true,
                                cancelable: true,
                                clientX: targetCenter.x,
                                clientY: targetCenter.y,
                                dataTransfer: dataTransfer
                            });

                            dropEvent.preventDefault = () => {};
                            targetElement.dispatchEvent(dropEvent);
                            console.log(`[Planner Script] ‚úÖ √âtape ${step}: drop`);
                            break;

                        case 5:
                            // dragend sur source
                            const dragEndEvent = new DragEvent('dragend', {
                                bubbles: true,
                                cancelable: true,
                                clientX: targetCenter.x,
                                clientY: targetCenter.y,
                                dataTransfer: dataTransfer
                            });

                            sourceElement.dispatchEvent(dragEndEvent);
                            console.log(`[Planner Script] ‚úÖ √âtape ${step}: dragend`);

                            // Finaliser
                            setTimeout(() => {
                                console.log(`[Planner Script] ‚úÖ S√©quence de drag & drop native termin√©e`);
                                resolve(true);
                            }, 100);
                            return;
                    }

                    step++;
                    setTimeout(executeStep, 150); // D√©lai entre chaque √©tape

                } catch (error) {
                    console.error(`[Planner Script] ‚ùå Erreur √† l'√©tape ${step}:`, error);
                    resolve(false);
                }
            };

            executeStep();
        });

    } catch (error) {
        console.error(`[Planner Script] ‚ùå Erreur lors du drag & drop natif:`, error);
        return Promise.resolve(false);
    }
}

// Fonction pour simuler le d√©placement d'une t√¢che vers la zone de drop
async function tryMoveTaskToDropZone(taskCard, numeroReparation, texteLabel) {
    console.log(`[Planner Script] tryMoveTaskToDropZone appel√©e pour ${numeroReparation} avec texte: "${texteLabel}"`);

    // V√©rifier si la t√¢che contient "PIECE EN PROD" - si oui, ne pas la d√©placer
    if (texteLabel.includes('PIECE EN PROD')) {
        console.log(`[Planner Script] ‚ùå T√¢che ${numeroReparation} contient "PIECE EN PROD", pas de d√©placement`);
        return;
    }

    // V√©rifier si la t√¢che correspond √† un √©l√©ment de la liste configurable - si oui, ne pas la d√©placer
    const autoListFinish = getList();
    const matchInList = autoListFinish.some(item => texteLabel.includes(item));
    if (matchInList) {
        console.log(`[Planner Script] ‚ùå T√¢che ${numeroReparation} correspond √† la liste configurable ("${texteLabel}"), pas de d√©placement`);
        return;
    }

    console.log(`[Planner Script] ‚úÖ T√¢che ${numeroReparation} autoris√©e pour d√©placement`);

    // Chercher la colonne "En cours" sp√©cifiquement
    const targetColumn = document.querySelector('#column_InProgress, li[id*="InProgress"], li[aria-label*="En cours"]');
    let dropZone = null;

    if (targetColumn) {
        // NOUVEAU: Chercher d'abord le listBoxGroup (structure apr√®s d√©placement)
        const listBoxGroup = targetColumn.querySelector('.listBoxGroup');
        if (listBoxGroup) {
            dropZone = listBoxGroup;
            console.log(`[Planner Script] ‚úÖ Colonne "En cours" trouv√©e avec listBoxGroup (structure post-d√©placement): ${listBoxGroup.className}`);
        } else {
            // Chercher le listWrapper dans la colonne "En cours" (zone de drop principale initiale)
            const listWrapper = targetColumn.querySelector('.listWrapper');
            if (listWrapper) {
                dropZone = listWrapper;
                console.log(`[Planner Script] ‚úÖ Colonne "En cours" trouv√©e avec listWrapper: ${listWrapper.className}`);
            } else {
                // Fallback vers bottomDropZone (zone de drop secondaire)
                const bottomDropZone = targetColumn.querySelector('.bottomDropZone');
                if (bottomDropZone) {
                    dropZone = bottomDropZone;
                    console.log(`[Planner Script] ‚úÖ Colonne "En cours" trouv√©e avec bottomDropZone: ${bottomDropZone.className}`);
                } else {
                    // Fallback vers le conteneur de t√¢ches dans la colonne "En cours"
                    const taskContainer = targetColumn.querySelector('.taskBoardColumnGroup, [data-dnd-role="columnGroup"]');
                    if (taskContainer) {
                        dropZone = taskContainer;
                        console.log(`[Planner Script] ‚úÖ Colonne "En cours" trouv√©e avec conteneur de t√¢ches: ${taskContainer.className}`);
                    } else {
                        // Fallback vers la colonne elle-m√™me
                        dropZone = targetColumn;
                        console.log(`[Planner Script] ‚úÖ Colonne "En cours" trouv√©e (fallback): ${targetColumn.className}`);
                    }
                }
            }
        }
    } else {
        console.log(`[Planner Script] ‚ö†Ô∏è Colonne "En cours" non trouv√©e pour ${numeroReparation}`);
        return;
    }

    if (!dropZone) {
        console.log(`[Planner Script] ‚ùå Aucune zone de drop trouv√©e pour la t√¢che ${numeroReparation}`);
        return;
    }

    // Trouver l'√©l√©ment parent de la t√¢che (taskBoardCard)
    const taskContainer = taskCard.closest('.taskBoardCard');
    if (!taskContainer) {
        console.log(`[Planner Script] ‚ùå Conteneur de t√¢che (taskBoardCard) non trouv√© pour ${numeroReparation}`);
        return;
    }

    console.log(`[Planner Script] üöÄ D√©marrage du d√©placement de la t√¢che ${numeroReparation} vers la zone de drop`);

    setTimeout(async () => {
        try {
            // Sauvegarder la position originale
            const originalParent = taskContainer.parentElement;

            console.log(`[Planner Script] √âl√©ment √† d√©placer:`, taskContainer);
            console.log(`[Planner Script] Parent original:`, originalParent?.className);
            console.log(`[Planner Script] Zone de destination:`, dropZone);

            // Essayer de d√©placer vers diff√©rentes cibles dans l'ordre de priorit√©
            const possibleTargets = [
                // Priorit√© 1: listBoxGroup (structure apr√®s d√©placement - NOUVELLE PRIORIT√â)
                targetColumn?.querySelector('.listBoxGroup'),
                // Priorit√© 2: listWrapper (zone de drop principale selon votre HTML)
                targetColumn?.querySelector('.listWrapper'),
                // Priorit√© 3: bottomDropZone (zone de drop secondaire)
                targetColumn?.querySelector('.bottomDropZone'),
                // Priorit√© 4: Conteneur de t√¢ches dans la colonne "En cours"
                targetColumn?.querySelector('.taskBoardColumnGroup'),
                targetColumn?.querySelector('[data-dnd-role="columnGroup"]'),
                // Priorit√© 5: La colonne "En cours" elle-m√™me
                targetColumn,
                // Priorit√© 6: Zone de drop s√©lectionn√©e
                dropZone
            ].filter(target => target && target !== taskContainer);

            let moveSuccess = false;

            for (const [index, target] of possibleTargets.entries()) {
                try {
                    const targetName = target.id || target.className || target.tagName;
                    console.log(`[Planner Script] Tentative ${index + 1}: D√©placement vers "${targetName}"`);

                    // Strat√©gie sp√©cifique selon le type de cible
                    let finalTarget = target;

                    if (target.classList?.contains('listBoxGroup')) {
                        // C'est la zone de drop apr√®s d√©placement - PRIORIT√â ABSOLUE
                        finalTarget = target;
                        console.log(`[Planner Script] üéØ Cible OPTIMALE trouv√©e: listBoxGroup (structure post-d√©placement)`);
                    } else if (target.classList?.contains('listWrapper')) {
                        // C'est la zone de drop principale parfaite, l'utiliser directement
                        finalTarget = target;
                        console.log(`[Planner Script] Cible optimale trouv√©e: listWrapper (zone de drop principale)`);
                    } else if (target.classList?.contains('bottomDropZone')) {
                        // C'est la zone de drop secondaire, l'utiliser directement
                        finalTarget = target;
                        console.log(`[Planner Script] Cible secondaire trouv√©e: bottomDropZone`);
                    } else if (target.id === 'column_InProgress') {
                        // C'est la colonne "En cours", chercher d'abord listBoxGroup (structure post-d√©placement), puis listWrapper, puis bottomDropZone
                        const listBoxGroup = target.querySelector('.listBoxGroup');
                        if (listBoxGroup) {
                            finalTarget = listBoxGroup;
                            console.log(`[Planner Script] üéØ listBoxGroup trouv√©e dans la colonne (OPTIMAL): ${listBoxGroup.className}`);
                        } else {
                            const listWrapper = target.querySelector('.listWrapper');
                            if (listWrapper) {
                                finalTarget = listWrapper;
                                console.log(`[Planner Script] listWrapper trouv√©e dans la colonne: ${listWrapper.className}`);
                            } else {
                                const bottomDropZone = target.querySelector('.bottomDropZone');
                                if (bottomDropZone) {
                                    finalTarget = bottomDropZone;
                                    console.log(`[Planner Script] bottomDropZone trouv√©e dans la colonne: ${bottomDropZone.className}`);
                                } else {
                                    const innerTaskContainer = target.querySelector('.taskBoardColumnGroup') ||
                                                             target.querySelector('[data-dnd-role="columnGroup"]');
                                    if (innerTaskContainer) {
                                        finalTarget = innerTaskContainer;
                                        console.log(`[Planner Script] Conteneur de t√¢ches trouv√© dans la colonne: ${innerTaskContainer.className}`);
                                    }
                                }
                            }
                        }
                    }

                    // Simuler une vraie action de drag & drop
                    let success = await simulateDragAndDrop(taskContainer, finalTarget);

                    // Si la premi√®re approche √©choue, essayer la fonction native
                    if (!success) {
                        console.log(`[Planner Script] ‚ö†Ô∏è Premi√®re approche √©chou√©e, tentative de drag & drop natif...`);
                        success = await simulateNativeDragAndDrop(taskContainer, finalTarget);
                    }

                    if (success) {
                        console.log(`[Planner Script] ‚úÖ Drag & Drop simul√© avec succ√®s vers: "${finalTarget.id || finalTarget.className}"`);

                        // Attendre un peu pour que l'interface se mette √† jour
                        await new Promise(resolve => setTimeout(resolve, 1500));

                        // V√©rifier si on est bien dans la colonne "En cours"
                        const inProgressColumn = taskContainer.closest('#column_InProgress, li[aria-label*="En cours"]');
                        if (inProgressColumn) {
                            console.log(`[Planner Script] ‚úÖ Confirm√©: T√¢che d√©plac√©e dans la colonne "En cours"`);
                        } else {
                            console.log(`[Planner Script] ‚ö†Ô∏è Attention: T√¢che pas dans la colonne "En cours"`);
                        }

                        moveSuccess = true;
                        break;
                    }
                } catch (moveError) {
                    console.log(`[Planner Script] √âchec d√©placement vers target ${index + 1}:`, moveError.message);
                    continue;
                }
            }

            // Indicateur visuel
            const indicator = document.createElement('div');
            indicator.style.position = 'fixed';
            indicator.style.top = '10px';
            indicator.style.right = '100px';
            indicator.style.background = moveSuccess ? 'rgba(0, 200, 0, 0.9)' : 'rgba(255, 165, 0, 0.9)';
            indicator.style.color = 'white';
            indicator.style.padding = '5px 10px';
            indicator.style.borderRadius = '4px';
            indicator.style.zIndex = '10000';
            indicator.style.fontSize = '12px';
            indicator.style.fontWeight = 'bold';
            indicator.textContent = moveSuccess ? `‚úÖ D√©plac√©: ${numeroReparation}` : `üîÑ Tentative: ${numeroReparation}`;
            document.body.appendChild(indicator);

            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 6000);

        } catch (error) {
            console.error(`[Planner Script] Erreur lors du d√©placement de la t√¢che ${numeroReparation}:`, error);
        }
    }, 1500); // D√©lai de 1.5 seconde apr√®s la validation du statut
}

function testerLienHttp(lien, taskCard, tentative = 1) {
    liensEnCours++;

    const maxTentatives = 5;
    const numeroReparation = lien.match(/\/(\d+)\.html$/)?.[1] || 'inconnu';

    GM_xmlhttpRequest({
        method: 'GET',
        url: lien,
        onload: function (response) {
            const overlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);

            if (response.status === 200) {
                const html = response.responseText;
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                const label = doc.querySelector('span.label-success');

                const symbole = doc.getElementById('idSymbole')?.value?.trim() || 'non trouv√©';
                const idUser = doc.getElementById('idUser')?.value?.trim() || 'non trouv√©';

                let texteLabel = label?.textContent?.trim() || 'non trouv√©';

                // Traiter le cas PV d'abord avant les autres actions
                if (texteLabel === 'non trouv√©' && response.finalUrl?.includes('/Prm/AfficherPv/')) {
                    texteLabel = 'Termin√© / PV';
                }

                console.log(`[Planner Script] üìä Traitement de la t√¢che ${numeroReparation} avec statut: "${texteLabel}"`);

                // V√©rifier les conditions d'exclusion pour le d√©placement
                const autoListFinish = getList();
                console.log(`[Planner Script] üîç Liste d'exclusion:`, autoListFinish);
                console.log(`[Planner Script] üîç V√©rification du statut "${texteLabel}" contre la liste`);

                const matchInList = autoListFinish.some(item => {
                    const match = texteLabel.includes(item);
                    if (match) {
                        console.log(`[Planner Script] üéØ Match trouv√©: "${item}" dans "${texteLabel}"`);
                    }
                    return match;
                });

                const containsPieceEnProd = texteLabel.includes('PIECE EN PROD');

                if (containsPieceEnProd) {
                    console.log(`[Planner Script] ‚õî D√©placement ignor√© pour ${numeroReparation} (PIECE EN PROD)`);
                } else if (matchInList) {
                    console.log(`[Planner Script] ‚õî D√©placement ignor√© pour ${numeroReparation} (correspond √† la liste configurable: "${texteLabel}")`);
                } else {
                    console.log(`[Planner Script] üöÄ D√©placement autoris√© pour ${numeroReparation} (statut: "${texteLabel}")`);
                    tryMoveTaskToDropZone(taskCard, numeroReparation, texteLabel);
                }

                // Puis g√©rer les clics complete avec un d√©lai pour √©viter les conflits
                setTimeout(() => {
                    tryClickComplete(taskCard, numeroReparation, texteLabel);
                }, 2000); // D√©lai de 2 secondes apr√®s le d√©placement

                // ‚úÖ R√©cup√©rer le nombre d'historique (si existe)
                let nombreHistorique = 0;
                const h3List = Array.from(doc.querySelectorAll('h3'));

                for (const h3 of h3List) {
                    const spanParent = h3.querySelector('span');
                    if (spanParent && spanParent.textContent.includes('Historique')) {
                        const badge = spanParent.querySelector('.badge.badge-onglet');
                        if (badge) {
                            const val = parseInt(badge.textContent.trim());
                            if (!isNaN(val)) {
                                nombreHistorique = val;
                            }
                        }
                        break; // d√®s qu'on a trouv√© un bloc historique, on sort
                    }
                }

                const leftSection = taskCard.querySelector('.leftSection');
                if (leftSection) {
                    // V√©rifie si un √©l√©ment historique a d√©j√† √©t√© inject√©
                    if (!leftSection.querySelector('.badge-historique')) {
                        const historiqueDiv = document.createElement('div');
                        historiqueDiv.className = 'badge-historique';
                        historiqueDiv.textContent = `Historique : ${nombreHistorique}`;
                        historiqueDiv.style.marginLeft = 'auto';
                        historiqueDiv.style.padding = '2px 6px';
                        historiqueDiv.style.background = 'rgba(0,0,0,0.3)';
                        historiqueDiv.style.color = '#fff';
                        historiqueDiv.style.fontSize = '11px';
                        historiqueDiv.style.borderRadius = '4px';
                        historiqueDiv.style.alignSelf = 'center';

                        leftSection.appendChild(historiqueDiv);
                    }
                }

                if (nombreHistorique > 0 && idUser !== 'non trouv√©') {
                    const urlHistorique = `https://prod.cloud-collectorplus.mt.sncf.fr/Prm/Reparation/ongletHistorique/${numeroReparation}?idUser=${idUser}&current_repair_id=${numeroReparation}`;

                    GM_xmlhttpRequest({
                        method: 'GET',
                        url: urlHistorique,
                        onload: function (res) {
                            const parser = new DOMParser();
                            const docHistorique = parser.parseFromString(res.responseText, 'text/html');
                            const lignes = Array.from(docHistorique.querySelectorAll('#dataTablesHistoriqueReparation tbody tr'));

                            const donnees = lignes.map(tr => {
                                const tds = tr.querySelectorAll('td');
                                return {
                                    numeroSerie: tds[2]?.textContent.trim(),
                                    numeroOf: tds[3]?.textContent.trim(),
                                    typeOf: tds[4]?.textContent.trim(),
                                    dateDebut: tds[6]?.textContent.trim(),
                                    etat: tds[7]?.textContent.trim(),
                                    consistance: tds[8]?.textContent.trim(),
                                };
                            });

                            const badge = leftSection.querySelector('.badge-historique');
                            if (badge) {
                                const overlay = document.createElement('div');
                                overlay.className = 'overlay-historique';
                                overlay.style.position = 'absolute';
                                overlay.style.top = '50%';
                                overlay.style.left = '50%';
                                overlay.style.transform = 'translate(-50%, -50%)';
                                overlay.style.background = 'rgba(0,0,0,0.85)';
                                overlay.style.color = '#fff';
                                overlay.style.padding = '10px';
                                overlay.style.borderRadius = '6px';
                                overlay.style.boxShadow = '0 2px 10px rgba(0,0,0,0.5)';
                                overlay.style.fontSize = '11px';
                                overlay.style.zIndex = '99999';
                                overlay.style.display = 'none';
                                overlay.style.overflowX = 'auto';

                                const table = document.createElement('table');
                                table.style.borderCollapse = 'separate';
                                table.style.width = '100%';
                                table.style.borderSpacing = '7px';
                                table.querySelectorAll('td, th').forEach(cell => {
                                    cell.style.padding = '4px 7px';
                                });
                                table.innerHTML = `<thead><tr><th>N¬∞ S√©rie</th><th>OF</th><th>Type</th><th>Date D√©but</th><th>√âtat</th><th>Consistance</th></tr></thead><tbody>${donnees.map(d => `<tr><td>${d.numeroSerie}</td><td>${d.numeroOf}</td><td>${d.typeOf}</td><td>${d.dateDebut}</td><td>${d.etat}</td><td>${d.consistance}</td></tr>`).join('')}</tbody>`;

                                overlay.appendChild(table);
                                document.body.appendChild(overlay);

                                badge.addEventListener('mouseenter', () => overlay.style.display = 'block');
                                badge.addEventListener('mouseleave', () => overlay.style.display = 'none');
                            }
                        }
                    });
                }

                const modificateur = extraireValeurParLibelle(doc, 'Derni√®re modif par :');
                const dateModif    = extraireValeurParLibelle(doc, 'Date derni√®re modif :');
                const infoAgent    = extraireValeurParLibelle(doc, 'Info Agent :');

                const index = donneesTaches.findIndex(t => t.numeroReparation === numeroReparation);
                const nouvelleTache = {
                    lien,
                    numeroReparation,
                    label: texteLabel,
                    idSymbole: symbole,
                    idUser: idUser,
                    modificateur,
                    dateModif,
                    infoAgent
                };

                if (index !== -1) {
                    donneesTaches[index] = nouvelleTache;
                } else {
                    donneesTaches.push(nouvelleTache);
                }

                if (overlay) {
                    overlay.querySelector('.text-collector').textContent = texteLabel;
                    overlay.querySelector('.text-numeroreparation').textContent = numeroReparation;
                    overlay.classList.remove('http-error');
                }

                const topBar = taskCard.querySelector('.topBar');
                if (topBar) {
                    let infoBox = topBar.querySelector('.collector-infos');
                    if (!infoBox) {
                        infoBox = document.createElement('div');
                        infoBox.className = 'collector-infos';
                        infoBox.style.marginBottom = '15px';
                        infoBox.style.background = 'rgba(0,0,0,0.5)';
                        infoBox.style.border = '1px solid #f97731';
                        infoBox.style.borderRadius = '4px';
                        infoBox.style.padding = '4px 6px';
                        infoBox.style.fontSize = '11px';
                        infoBox.style.lineHeight = '1.4';
                        infoBox.style.color = 'rgb(204,204,204)';
                        infoBox.style.fontFamily = "'Montserrat', sans-serif";
                        infoBox.style.fontWeight = '400';

                        // üü† Ins√©rer AVANT le premier enfant de .topBar
                        topBar.insertBefore(infoBox, topBar.firstChild);
                    } else {
                        infoBox.innerHTML = '';
                    }

                    const addInfo = (label, val) => {
                        const span = document.createElement('span');
                        span.style.display = 'block';
                        span.innerHTML = `<strong>${label}</strong> ${val}`;
                        infoBox.appendChild(span);
                    };

                    if (texteLabel === 'Termin√© / PV') {
                        addInfo('Termin√©', '');
                    } else {
                        addInfo('Modifi√© par :', modificateur);
                        addInfo('Date modif :', dateModif);
                        addInfo('Info Agent :', infoAgent);
                    }

                    masquerPlanProduction();
                }

                liensEnCours = Math.max(0, liensEnCours - 1);

            } else {
                if (tentative < maxTentatives) {
                    setTimeout(() => testerLienHttp(lien, taskCard, tentative + 1), 2000);
                } else {
                    if (overlay) {
                        overlay.querySelector('.text-collector').textContent = `Erreur ${response.status}`;
                        overlay.classList.add('http-co-error');
                    }
                    liensEnCours = Math.max(0, liensEnCours - 1);
                }
            }
        },
        onerror: function () {
            if (tentative < maxTentatives) {
                setTimeout(() => testerLienHttp(lien, taskCard, tentative + 1), 2000);
            } else {
                const overlay = taskCard.querySelector(`#idreparation-status-${numeroReparation}`);
                if (overlay) {
                    overlay.querySelector('.text-collector').textContent = `Erreur r√©seau`;
                    overlay.classList.add('http-error');
                }
                liensEnCours = Math.max(0, liensEnCours - 1);
            }
        }
    });
}

function masquerPlanProduction() {
    const plans = document.querySelectorAll('div.planName');

    for (const plan of plans) {
        const texte = plan.textContent.trim();
        if (texte.includes('Production ')) {
            plan.style.display = 'none';
        }
    }
}

function extraireValeurParLibelle(doc, libelle) {
    const spans = [...doc.querySelectorAll('span')];
    for (const span of spans) {
        if (span.textContent.trim() === libelle) {
            const parentDiv = span.closest('div');
            const container = parentDiv?.parentElement;
            if (container) {
                const infos = container.querySelectorAll('div');
                if (infos.length >= 2) {
                    const valeur = infos[1]?.textContent?.trim();
                    if (valeur) return valeur;
                }
            }
        }
    }
    return '‚úñÔ∏è';
}
